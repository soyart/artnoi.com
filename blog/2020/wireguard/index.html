<!doctype html><html lang=en><head><title>Artnoi.com</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet></head><body><ul class=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><p>Oct 22, <a href=/blog/2020/>2020</a></p><h1 id=deploying-wireguard-on-openbsd-https-openbsd-org-and-arch-linux-https-archlinux-org>Deploying WireGuard on <a href=https://openbsd.org>OpenBSD</a> and <a href=https://archlinux.org>Arch Linux</a></h1><h2 id=my-wireguard-impression>My WireGuard impression</h2><p>I have been using <a href=https://www.wireguard.com/>WireGuard</a> on Arch Linux, macOS, and iOS since June 2020, and have been very satisfied with the results so far. WireGuard is (as per its author) <em>next-generation</em> VPN protocol, and it is considered a <em>blasphemy</em> in VPN world. WireGuard only operates on Layer 3, only uses UDP, and does not allow users to choose their cryptography of choice (instead, WireGuard enforces very strong cryptography - visit the <a href=https://wireguard.com>project website</a> for more info). The main idea of WireGuard is <a href=https://www.wireguard.com/#cryptokey-routing>crypto routing</a>.</p><p>This means that its code base is relatively much smaller than other VPN code, thus porting to other platforms can be done much more effectively despite being originally designed for the Linux kernel. Its speed, reliability, security, and how it appears state-less to the outsiders is what makes WireGuard very interesting choice for those looking for a way to encrypt their traffic.</p><p>This guide covers the basic interface configuration on both operating systems, as well as the corresponding firewall rules, <code>pf(4)</code> for OpenBSD, and <code>iptables(8)</code> (and optionally <code>ufw(8)</code>) for Arch Linux.</p><h2 id=wireguard-on-openbsd>WireGuard on OpenBSD</h2><p>OpenBSD is <a href=/blog/2020/openbsd-server/>my webserver operating system</a> - <strong>it comes complete</strong> with all the server tools I need. WireGuard functionality was also available on OpenBSD as external packages <code>wireguard-go</code> and <code>wireguard-tools</code>. Just recently, the OpenBSD developers decided they would include WireGuard code into their base networking stack with their 6.8 <em>Release</em>, removing the need for external packages. This means that OpenBSD is even more complete as a server operating system for me. Next is how we can configure the <code>wg(4)</code> interface (or <code>tun(4)</code> in pre-6.8 OpenBSD).</p><p>Note: WireGuard servers which act as VPN routers must have IP routing enabled, if you are only using Wireguard to connect peers, then you can skip this step:</p><pre><code class=language-shell>touch /etc/sysctl.conf
echo 'net.inet.ip.forwarding=1' &gt;&gt; /etc/sysctl.conf
</code></pre><p>This should make the configuration persistent on next boots.</p><h3 id=openbsd-6-8-native-wireguard>OpenBSD 6.8 - native WireGuard</h3><p>WireGuard was <a href=https://man.openbsd.org/wg>ported to base as <code>wg(4)</code></a> in OpenBSD 6.8, which means that <code>wireguard-go</code> package is now outdated. This means now <strong>one can configure <code>wg(4)</code> interface directly from <code>hostname.wgX</code> (via <code>ifconfig(8)</code>) file without having to use WireGuard user-space tools</strong>.</p><p>I upgraded to 6.8 a few days ago, and promptly removed <code>wireguard-go</code> and <code>wireguard-tools</code> to minimize the number of external packages. To configure WireGuard on OpenBSD, add the following information to <code>hostname.wgX</code> file, for example <code>hostname.wg0</code>. I only relied on the manual page for <code>wg(4)</code> to set this interface up, but here is another guide I write as a quick reminder for myself.</p><p>In this example, <strong>we will NOT use any WireGuard packages, so <code>wg genkey</code>, <code>wg pubkey</code>, etc. must be done on other machines</strong>. The example will use 10.9.0.0/24 network. The <code>hostname.wg0</code> interface configuration (<a href=https://man.openbsd.org/hostname.if.5>see <code>hostname.if(5)</code></a>) file for OpenBSD 6.8 should look like this:</p><pre><code># /etc/hostname.wg0

# Interface configuration
wgkey yourPrivateKey=
wgport yourListenPort
inet 10.9.0.1/24
up

# Adding WireGuard peers
!ifconfig wg0 wgpeer dfjsldkfldsk=  wgendpoint example.com 11210 wgaip 10.9.0.2/32
!ifconfig wg0 wgpeer adfjdksjdsdf=  wgaip 10.9.0.3/32 # this peer doesn't have endpoint
</code></pre><p><strong>Note that <code>wgpeer</code> values are the peer public keys</strong>. For the lines starting with <code>!</code>, <a href=https://man.openbsd.org/netstart><code>netstart(8)</code></a> will run the command after the <code>!</code>. See the man pages for <code>wg(4)</code>.</p><p>After you are done with <code>hostname.wg0</code> file, try bringing up the interface with</p><pre><code class=language-shell>sh /etc/netstart wg0;
</code></pre><p>After editting the file, reboot, and at the next boot we can check the <code>wg0</code> interface by using <code>ifconfig(8)</code>: <code># ifconfig -A</code>. If <code>ifconfig -A</code> is not run as root, you will not see the public keys. OpenBSD with WireGuard included in the kernel is surely a bless for me.</p><h3 id=pre-6-8-using-wireguard-go-and-wireguard-tools>Pre 6.8 - using <code>wireguard-go</code> and <code>wireguard-tools</code></h3><p>The VPS I use to run this website is on OpenBSD (<a href=/blog/2020/openbsd-server/>originally 6.7</a>), and WireGuard is also available on the platform as installable packages <code>wireguard-go</code> which is the WireGuard implementation in Go, and <code>wireguard-tools</code> which provides user-space WireGuard tools like <code>wg-quick(8)</code> (<code>wireguard-tools</code> depends on <code>bash</code> - FYI) etc.</p><p>With the packages, we can generate our keys locally:</p><pre><code class=language-shell>wg genkey | tee foo.key | wg pubkey &gt; foo.pub;
wg genpsk &gt; foo.psk;
</code></pre><p>To configure the VPN interface on OpenBSD 6.7 where WireGuard is not yet available in the kernel, we will have to write both <a href=https://man.openbsd.org/hostname.if.5><code>hostname.tunX</code> (<code>hostname.if(5)</code>)</a> file to configure the <a href=https://man.openbsd.org/tun.4><code>tun(4)</code></a> interface as well as a WireGuard configuration file (i.e. the file in <code>/etc/wireguard</code>), and also <code>rc.conf.local(8)</code> to start the <code>wireguard_go</code> service. <a href=https://jasper.la/posts/wireguard-on-openbsd/>This is the guide by Jasper (the porter)</a> to WireGuard I followed when I was running 6.7. I personally prefer OpenBSD 6.8&rsquo;s approach to WireGuard which is much simpler.</p><h3 id=pf-4-https-man-openbsd-org-pf-4-configuration><a href=https://man.openbsd.org/pf.4>pf(4)</a> configuration</h3><p><code>pf(4)</code> (packet filter) is OpenBSD&rsquo;s <em>firewall</em> that is so good it is ported to many other operating systems, most notoriously FreeBSD and its derivatives (<a href=https://pfsense.org>pfSense</a>, macOS, iOS, etc.). On OpenBSD, <code>pf(4)</code> is usually interacted with via <code>pfctl(8)</code>.</p><p>It took me a few hours until I could figure out the filter rules for WireGuard (yes, I am that dumb). <strong>I recommend that you first start from basic configuration, then test the connection, and start building the firewall up from there</strong>. Below is a working configuration for my use case - the server is able to both reach other endpoints, and other clients can also reach the server&rsquo;s endpoint. Here, I will demonstrate how to build the firewall rules up from the basic. The following example uses <a href=https://www.openbsd.org/faq/pf/macros.html><em>macros</em> and <em>lists</em></a> to build the rules. If <code># pfctl -n -f /etc/pf.conf</code> throws errors, it may be from failure to expand these lists and macros.</p><p>My goal is to have a firewall that silently drops all non-WireGuard packets other than the ones I explicitly allow. I first determine which interfaces would be skipped by <code>pf(4)</code> in <code>pf.conf(5)</code>:</p><pre><code># /etc/pf.conf
wgif = &quot;{ wg0, wg1 }&quot; # maybe 'tunX' on OpenBSD pre-6.8
skif = &quot;{ lo0, $wgif }&quot;

# skip packet filtering on these
set skip on $skif
</code></pre><p>Then I set the default block policy to <code>drop</code>, and enter my first two rules <code>block all</code>, and <code>block in quick urpf-failed</code>. This should set our default policy to block all traffic on all interfaces sans the skip inferfaces <code>$skif</code> (which expands to <code>lo0</code>, <code>wg0</code>, and <code>wg1</code>), and all incoming traffic that failed URPF (Unicast reverse path forwarding) test.</p><p>In <code>pf.conf(5)</code>, <em>last matching rule wins</em>, so it&rsquo;s nice to put the <code>block all</code> line before any <code>pass</code> rules:</p><pre><code># silently drop traffic
set block-policy drop

# default is to block all traffic
block all

# block incoming traffic that failed urpf
block in quick urpf-failed
</code></pre><p>I then open some external ports for WireGuard (<code>wgports</code> 32624 and 42836) to all UDP traffic for WireGuard, and also other rules I want to apply to non-WireGuard interfaces:</p><pre><code># wireguard needs open udp port(s) for listening
wgports = &quot;{ 32624, 42836 }&quot;
pass quick log proto udp to port $wgports

# open tcp ports, such as ssh and webserver
tcpports = &quot;{ 22, 80, 443 }&quot;
pass quick log proto tcp to port $tcpports

# dns lookups
pass quick out proto udp to port 53
</code></pre><p>Then, I added the following line for <code>pf(4)</code> to properly handle WireGuard traffic, as well as NAT. Although most of the times <code>pf.conf</code> <em>actions</em> can be arbitarily positioned, this time <code>proto udp</code> must come after <code>pass in on egress inet</code>:</p><pre><code># pf config for WireGuard
pass in on egress inet proto udp from any to any port $wgports
pass out on egress inet from ($wgif:network) nat-to (egress:0)
</code></pre><p>And test the configuration, as well as actually reload the firewall rules with <code>pfctl(8)</code>:</p><pre><code class=language-shell>pfctl -n -f /etc/pf.conf; # dry-run
pfctl -f /etc/pf.conf;
</code></pre><p>Now you can try the connection by pinging other hosts in the WireGuard network.</p><h2 id=wireguard-on-arch-linux>WireGuard on Arch Linux</h2><p>Because WireGuard is originally designed for the Linux kernel, and is now part of the kernel since version 5.7, we only need to install <code>wireguard-tools</code> which provide <code>wg(8)</code> and <code>wg-quick(8)</code>:</p><pre><code class=language-shell>pacman -S wireguard-tools;
</code></pre><p>If you use non-default Linux kernel, you may have to install a corresponding WireGuard kernel module, e.g. <code>wireguard-dkms</code> or <code>wireguard-lts</code>.</p><p>Then, we simply write a text configuration file (for example, <code>wg0.conf</code> in <code>/etc/wireguard</code>). You can just follow the guide on the <a href=https://wiki.archlinux.org/index.php/WireGuard>Arch Wiki</a>. After the connection is working, we can persistently enable the connection as a <code>systemd(1)</code> service like so:</p><pre><code class=language-shell>systemctl enable --now wg-quick@wg0.service
</code></pre><p>Note that on Arch, <code>@wg0.service</code> part refers to <code>/etc/wireguard/wg0.conf</code> file, i.e. if you have <code>/etc/wireguard/server.conf</code> the service name is <code>wg-quick@server.service</code>. After the service is running, we can check the connection status by issuing: <code># wg</code>.</p><h3 id=iptables-8-and-ufw-8><code>iptables(8)</code> and <code>ufw(8)</code></h3><p>Also, we need to put the commands to set firewall rules for both IPv4 and IPv6 in <code>PostUp</code> and <code>PostDown</code> section in your WireGuard configuration in order to properly set up the connection (note that the following configuration features 2 example interfaces <code>em0</code> and <code>em1</code>):</p><pre><code># Adding iptables rules (-A) for wg0 after bringing the interface up
PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; \
iptables -t nat -A POSTROUTING -o em0 -j MASQUERADE; \
ip6tables -A FORWARD -i wg0 -j ACCEPT; \
ip6tables -t nat -A POSTROUTING -o em0 -j MASQUERADE; \
iptables -A FORWARD -i wg0 -j ACCEPT; \
iptables -t nat -A POSTROUTING -o em1 -j MASQUERADE; \
ip6tables -A FORWARD -i wg0 -j ACCEPT; \
ip6tables -t nat -A POSTROUTING -o em1 -j MASQUERADE

# Deleteing iptables rules (-D) for wg0 after bringing the interface down
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; \
iptables -t nat -D POSTROUTING -o em0 -j MASQUERADE; \
ip6tables -D FORWARD -i wg0 -j ACCEPT; \
ip6tables -t nat -D POSTROUTING -o em0 -j MASQUERADE; \
iptables -D FORWARD -i wg0 -j ACCEPT; \
iptables -t nat -D POSTROUTING -o em1 -j MASQUERADE; \
ip6tables -D FORWARD -i wg0 -j ACCEPT; \
ip6tables -t nat -D POSTROUTING -o em1 -j MASQUERADE
</code></pre><p>I then use <code>ufw</code> to easily configure open UDP port (in this example <code>42836</code>) for WireGuard:</p><pre><code class=language-shell>ufw allow 42836/udp;
</code></pre><p>With this configuration, your Arch WireGuard should be able to do crypto routing and NAT-ing.</p><h2 id=my-usage-of-wireguard>My usage of WireGuard</h2><p>I do everything almost always under WireGuard connection, except of course the webserver outgoing connection. All of my services, e.g. DNS lookups, Plex, Syncthing, and NFS all are done over the <code>wgX</code> interface(s). I also optionally have another interface <code>wgY</code> specifically for routing all of my traffic over VPN to overseas endpoints.</p><p>Here is some good use cases of WireGuard as a point-to-point VPN, i.e. (virtually) directly connecting two hosts. My <a href=https://syncthing.net>Syncthing</a> configuration explicitly requires WireGuard connection for peer discovery, transfer, and web GUI. Another example is DNS-over-VPN. In my case, my home <a href=/blog/2020/covid-19/>ThinkCentre</a> is configured a fully encrypted nameserver - it uses <code>stubby</code> (DNS-over-TLS) as a stub resolver, and <a href=https://pihole.com>Pi-Hole</a> (<code>dnsmasq</code>) as DNS server. With WireGuard, I could remotely access my home DNS server, get the ad-blocking functionality, as well as encrypt my <em>otherwise plain-text</em> port 53 DNS queries. Unless <code>stubby</code> is down, no one should be able to see my DNS requests.</p><blockquote><p>One advantages of WireGuard over plain connection is how godly it can survive network timeouts - if I <code>ssh</code> over WireGuard, I could shut my <a href=/blog/2019/thinkpad/>notebook</a> lid and when I open it back up, and the connection would still be there.</p></blockquote><h2 id=conclusion>Conclusion</h2><p>WireGuard is a great VPN tool - it is easy to understand, easy to use, easy to setup on new devices. Adding a new peer only requires copy-pasting a few lines of configuration. On top of that, it is fast, secure, and available to almost all popular computing platforms. From my experience, its speed (both transfer and handshake) and robustness far surpassed OpenVPN, and these points are especially important when your remote hosts is far away. This is why I see no reason why one should use something else, unless it is a requirement by the organization to use other VPN protocols.</p><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>
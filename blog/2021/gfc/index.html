<!doctype html><html lang=en><title>Artnoi.com</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet><ul class=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a><li class=f-right><a href=/cheat/>cheat</a><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a><li class=f-right><a href=/blog/>blog</a></ul><p>Mar 16, <a href=/blog/2021>2021</a><p><h1>gfc (go file crypt)</h1><blockquote><p>For recent notes on gfc, see its <a href=https://gitlab.com/artnoi/gfc>README.md</a></blockquote><p>I just wrote a small Go command-line utility to encrypt/decrypt files using AES-256. Its early versions support AES-GCM and AES-CTR, key file, and PBKDFF2 passphase hash. It is meant to be reused later in other programs, but now it is also a small standalone command-line program.<p>This is my second real program (not a <code>sh(1)</code> script), the first being UNIX <code>cat(1)</code> clone called <a href=https://gitlab.com/artnoi/c/-/blob/master/src/kat.c>kat</a>.<p>Check gfc out on <a href=https://github.com/soyart/gfc>my Github</a> or <a href=https://gitlab.com/artnoi/gfc>GitLab</a> (more frequent updates on GitLab)<h2 id=gfc-features>gfc features</h2><ul><li><p>AES256-GCM (default)<li><p>AES256-CTR (optional)<li><p>PBKDF2 passphrase-key derivation (default)<li><p>Hexademical output (optional)</ul><h2 id=usage>Usage</h2><pre><code>-H &lt;bool&gt;
	Use hex output
-d &lt;bool&gt;
	Use decrypt mode
-k &lt;bool&gt;
	Use keyfile mode
-p &lt;bool&gt;
	Print output to stdout
-m &lt;string&gt;
	AES modes (GCM or CTR) (default &quot;GCM&quot;)
-f &lt;string&gt;
	Keyfile file (default &quot;files/key.key&quot;)
-i &lt;string&gt;
	Input file (default &quot;files/plain&quot;)
-o &lt;string&gt;
	Output file (default &quot;/tmp/delete.me&quot;)
</code></pre><h2 id=how-gfc-works>How gfc works</h2><pre><code>gfc
├── crypt
│   ├── ctr.go
│   ├── file.go
│   ├── gcm.go
│   └── key.go
├── files
│   ├── hex
│   ├── key.key
│   ├── plain
│   └── zeroes
├── gfc.go
├── go.mod
├── go.sum
├── README.md
└── test.sh
</code></pre><blockquote><p>gfc will import <code>gfc/crypt</code></blockquote><p><code>test.sh</code><p>This shell script is used to test multiple combinations of command-line arguments to gfc. It uses associative arrays, so it&rsquo;s not POSIX shell compatible.<p><code>files/</code><p>This directory stores files for testing gfc, i.e. a random file, a plaintext file, a hex file, a 256-bit random key, etc. The keyfile from the repository should be replaced with your own random key:<pre><code>$ cd gfc;
$ dd bs=1 count=32 if=/dev/random of=files/key.key;
</code></pre><p>gfc will <em>not</em> hash keyfiles, because I expect user&rsquo;s keyfile to be more random than its PBKDF2 hash.<ul><li><code>gfc.go</code></ul><p>The only file for <code>main</code> package is <code>gfc.go</code> and is responsible for controlling flows. Other code (e.g. I/O and AES) is in <code>gfc/crypt</code> directory.<p>This main file defines type <code>flags</code> that holds command-line flags information. The <code>flags</code> struct also has crypt.GfcFile embedded.<ul><li><code>crypt/file.go</code></ul><p>I/O and file operation methods are defined in <code>aesgfc/file.go</code>. This file also defines a struct; <code>aesgfc.GfcFile</code> for files used by gfc.<p>Currently, this struct and its methods wraps basic <code>os.File</code> methods like <code>Open()</code>, <code>Create()</code>, <code>Read()</code> and <code>Write()</code>. Other functions and methods include those that deal with hex encoding and decoding.<p>If gfc is given <code>-H</code> (hexadecimal), then (1) for encryption, the encrypted output buffer is encoded to hex with <code>EncodeBuf()</code> before being written to outfile, or (2) for decryption, the infile is read into a buffer, and that read buffer is decoded from hex to bytes with <code>DecodeFile()</code>.<ul><li><code>crypt/key.go</code></ul><p>This file contains code related to encryption key, e.g. reading passphrase from console, hashing passphrase, and reading keyfile. It also holds constants for gfc cryptography, e.g. the length of certain objects.<p><code>crypt/ctr.go</code> and <code>crypt/gcm.go</code><p>gfc supports 2 AES stream cipher modes; GCM (default) and CTR (optional). GCM mode enables message authentication, which should prevent the encrypted files from being tampered. Both modes are stream ciphers based on counter mode of block mode of operation.<h2 id=gcm-default-mode>GCM (default mode)</h2><p>In <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation>AES256-GCM mode</a>, the file bytes is broken <em>sequentially</em> into numbered blocks of 32 octets of bytes (256 bits).<p>Those block <em>counter</em> (block numbers) is then combined with an initialization vector <em>iv</em>, and later encrypted with an AES <em>block</em> cipher derived from the key.<p>The output from last operation is then used XORed with the underlying plaintext to produce the ciphertext output for the block. That resulting ciphertext is then used to compute the message authentication tag.<h2 id=ctr>CTR</h2><p>Because gfc needs to pass all the bytes to <code>gcm.Seal()</code> or <code>gcm.Open()</code> to encrypt and decrypt respectively, consuming large amount of memoty. So I provided <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation>AES256-CTR mode</a>, which encrypts data by fixed-sized chunks in memory, although gfc&rsquo;s <strong>CTR mode does not have any message authentication (e.g. HMAC) built-in</strong>.<h2 id=so-we-should-always-use-ctr-for-larger-files>So we should always use CTR for larger files?</h2><p><strong>But because I suck, the method <code>crypt/ctr.go</code> uses to read the file actually reads the whole file content</strong> (although in chunks) into memory as read buffer before passing it to the encrypter/decrypter.<p>Even worse, the way I wrote the write methods for gfc is that the output ciphertext or plaintext is first written to a buffer, so that I can use a reader interface on this buffer later when I encode it (which needs another buffer) to hex, and that buffer is then converted to <code>[]byte</code> before it is written to a file.<p>This is because I want to later use channels and Goroutines to concurrently read, encrypt, and encode to hex, or read, decode hex, and decrypt.<hr><p><a href=#top>Back to top</a><hr><footer><p>Copyright (c) 2019 - 2023 Prem Phansuriyanon<p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</footer>
<!DOCTYPE html><html lang=en> <head><title>Artnoi.com</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=keywords content="artnoi, Prem Phansuriyanon"><meta name=author content=@artnoi><meta charset=UTF-8><link href=/style.css rel=stylesheet></head> <body> <ul class=navbar> <li><a href=/ ><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li> <li class=f-right><a href=/cheat/ >cheat</a></li> <li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a></li> <li class=f-right><a href=/blog/ >blog</a></li> </ul> <p>Jan 30, <a href=/blog/2021/ >2021</a></p> <h1 id=pi-hole->Pi-Hole คืออะไร</h1> <p><a href=https://pi-hole.net>Pi-Hole</a> เป็นหลุมดำที่บล็อคโฆษณาในระดับ DNS จึงไม่จำเป็นต้องมีการเชื่อมต่อที่ไม่จำเป็นไปที่เซอร์เวอร์โฆษณา ทำให้ Pi-Hole ช่วยเพิ่มความเร็วในการดาวน์โหลดหน้าเว็บ และทำงานได้เร็วกว่าการบล็อคโฆษณาแบบปกติบนบราวเซอร์มากๆ</p> <blockquote> <p>ชื่อ Pi-Hole มากจากคอมพิวเตอร์ (SBC) Raspberry Pi และหลุมดำ Black hole เนื่องจากผู้ใช้นิยมติดตั้ง Pi-Hole ลงบน Raspberry Pi (หรือ SBC อื่นๆ) เพราะคอพิวเตอร์จิ๋วพวกนี้ประหยัดไฟและราคาถูกครับ</p> </blockquote> <h1 id=pi-hole--1>Pi-Hole ขั้นเทพ</h1> <p>ช่วงนี้ผมเริ่มเห็นคนไทยพูดคุยเรื่อง Pi-Hole มากขึ้นตามกลุ่ม hobbyist บนเฟซบุ๊ค แต่หลายๆคนยังใช้ Pi-Hole แบบเบสิคๆอยู่ วันนี้ผมเลยจะมาแนะนำวิธีทำ Pi-Hole ให้ปลอดภัยมากขึ้นครับ แต่ที่สำคัญกว่าคือเซ็ทอัพครั้งนี้สามารถทำได้บนหลายฮาร์ดแวร์และซอฟต์แวร์แพลตฟอร์มมากๆครับ</p> <h2 id=section>อะไรทำให้เทพ?</h2> <p>ในทุกๆเซอร์เวอร์ที่ผมรัน Pi-Hole หลักๆเลยผมมักจะ:</p> <ul> <li><p>ทำให้ Pi-Hole คุยกับ client <a href=/blog/2021/wireguard-th/ >ผ่าน WireGuard VPN เท่านั้น</a></p></li> <li><p>ใช้ TLS stub resolver อย่าง <code>stubby(1)</code> ที่สามาถทำ <a href=https://en.wikipedia.org/wiki/DNS_over_TLS>DNS-over-TLS (DoT)</a> พร้อมกับ <a href=https://en.wikipedia.org/wiki/Domain_Name_System_Security_Extensions>DNSSEC</a> เพื่อมารับช่วงต่อจาก Pi-Hole ครับ ถ้าจะให้พูดแบบทางการคือ DNS requests จะถูก wrap ด้วย TLS อนจะถูกส่งออกไปที่เซอร์เวอร์ DoT เพื่อความปลอดภัยที่สูงขึ้นครับ</p></li> <li><p>(เฉพาะเครื่องที่ต้องการติดตั้ง web interface เท่านั้น) แทนดีฟอลต์เว็บเซอร์เวอร์ <code>lightppd(8)</code> ด้วย <a href=https://nginx.com><code>nginx(8)</code></a> (why not?) หากเลือกเส้นทางนี้เราจะต้องติดตั้ง <code>php-fpm</code> เพิ่ม และต้องเขียนไฟล์ตั้งค่าขึ้นเองสำหรับ PHP และ NGINX (why not อีกนั่นแหละครับ)</p></li> </ul> <blockquote> <p>หลังจากเราทำการติดตั้งซอฟต์แวร์เพิ่มเติมและตั้งค่าใหม่ตามนี้แล้ว DNS requests ของเราจะปลอดภัยขึ้นเยอะมากครับ เพราะ (1) ฝั่ง in-bound (จาก client) ก็มาแบบ VPN (2) ฝั่ง out-bound จะถูกส่งออกไปแบบ TLS เอาง่ายๆก็คือหากมีคนดักฟังหรือมี man-in-the-middle แล้วเค้าจะไม่เห็น DNS query ของเราเลยครับ</p> <p>และหากคุณเลือกที่จะใช้ WireGuard คุณก็จะสามารถใช้ Pi-Hole ได้ทุกที่บนอินเตอร์เน็ต แม้คุณจะอยู่นอกบ้าน หรือใช้เครื่อข่าย cellular ก็ตาม (ต้องใช้ DDNS หากไม่มี public IP address เป็นขอตัวเองครับ) อย่างที่ผมใช้ คือตั้งพีซี ThinkCentre เครื่องนึงไว้เป็นเซอร์เวอร์ WireGuard และ Pi-Hole โดยเฉพาะ ทำให้ผมสามารถบล็อคแอดได้ทุกที่ และคิวรี่อย่างปลอดภัย ใต้ร่ม VPN ครับ</p> </blockquote> <h2 id=start->เตรียมความพร้อมก่อน <em>start</em> เซอร์วิสต่างๆ</h2> <blockquote> <p>ผมแนะนำให้ผู้ใช้ Pi-Hole อ่านหน้า <a href=https://wiki.archlinux.org/index.php/Pi-hole#Configuration>Arch Wiki เกี่ยวกับ Pi-Hole</a></p> </blockquote> <h3 id=1.-wireguard-vpn-firewall>1. WireGuard VPN และ Firewall</h3> <p><a href=/blog/2021/wireguard-th/ >ติดตั้งและตั้งค่า WireGuard VPN</a> หรือ VPN อื่นๆ รวมถึง Firewall ต่างๆ</p> <h3 id=2.-tls-stub-resolver->2. TLS stub resolver (ด้วย <code>stubby(1)</code>)</h3> <blockquote> <p>ทำไมต้องมี <code>stubby(1)</code>? ถ้าจะให้ตอบแบบง่ายคือเพื่อให้ DNS queries ที่ออกจาก Pi-Hole เป็นแบบ <a href=https://en.wikipedia.org/wiki/DNS_over_TLS>DNS-over-TLS</a> เพื่อความเป็นส่วนตัวและความปลอดภัยครับ เพราะ Pi-Hole หรือ <code>dnsmasq(8)</code> ไม่สามารถทำ DNS-over-TLS ได้ โดยการทำ DNS-over-TLS ก็มี trade-off นั่นคือ latency นั่นเอง การตั้งปริมาณ Pi-Hole DNS cache ให้เหมาะสมกับการใช้งานจึงสำคัญ</p> </blockquote> <p>ติดตั้ง <code>stubby(1)</code> ด้วย package manager ในตัวอย่างนี้ผมจะใช้ <code>pacman</code> ของ Arch Linux</p> <pre><code class=language-shell>pacman -S stubby;
</code></pre> <p>ตั้งค่า <code>stubby(1)</code> ที่ <code>&#47;etc&#47;stubby&#47;stubby.yml</code> โดยเราสามารถแก้ไขตามที่ต้องการ <a href=https://wiki.archlinux.org/index.php/Stubby>ตามที่ Arch Wiki แนะนำ</a>ได้เลยครับ ผมมักจะตั้งค่า DNSSEC และ policy ให้ strict ครับ แต่คุณเลือกได้ตามใจเลย แค่อย่าลืมแก้ไข <code>listen_address</code> ใน <code>stubby.yml</code> ให้ <code>stubby</code> ฟัง DNS requests ที่ loopback address (inet = <code>127.0.0.1</code>, inet6=<code>::1</code>) port อื่นที่ไม่ใช่ <code>53</code> นะครับ เพราะ Pi-Hole จะฟังที่พอร์ต <code>53</code> พอดีครับ <strong>แล้วก็ต้องปิดเซอร์วิสอื่นๆที่ฟังอยู่ที่พอร์ต <code>53</code> ด้วยครับไม่งั้น Pi-Hole จะสตาร์ทไม่ติดเพราะพอร์ตไม่ว่าง</strong></p> <p>ในตัวอย่างนี้จะใช้พอร์ต <code>5369</code> สำหรับ <code>stubby(1)</code> จึงต้องแก้ฟิล์ด <code>listen_address</code> ให้เป็น:</p> <pre><code>listen_addresses:
  - 127.0.0.1@5369
  -  0::1@5369
</code></pre> <p>อย่าลืมเว้นวรรค indent ให้ถูกต้องนะครับ ไม่งั้นไฟล์ <code>.yml</code> จะใช้งานไม่ได้ หลังจากเขียนไฟล์เสร็จ ลองเทสต์ว่าใช้ได้รึป่าวด้วยการรัย <code>$ stubby;</code> ครับ หากไม่มี error ก็ enable หรือ start <code>stubby.service</code> ได้เลยครับ:</p> <pre><code class=language-shell>systemctl enable --now stubby;
</code></pre> <p>หลังจากนั้น ให้ทดสอบการเชื่อมต่อแบบ DNS-over-TLS ด้วยการ query ไปที่ listen address ของ <code>stubby.service</code> ครับ:</p> <pre><code class=language-shell>dig @localhost -p 53690 artnoi.com;
</code></pre> <p>แล้วรอดูว่าได้ answer ถูกต้องไหม หากถูกต้องก็ข้ามไปสเตปต่อไปได้เลยครับ</p> <h3 id=3.-nginx-lighttpd>3. NGINX แทน lighttpd</h3> <p>ติดตั้ง <code>php(1)</code> และ <code>php-fpm(8)</code> และ <code>nginx(8)</code>:</p> <pre><code class=language-shell>pacman -S php php-fpm nginx-mainline;
</code></pre> <p>จากนั้น ให้แก้ไขไฟล์ตั้งค่า <code>&#47;etc&#47;php.ini</code> <code>&#47;etc&#47;nginx&#47;nginx.conf</code></p> <h4 id=section-1><code>&#47;etc&#47;php&#47;php.ini</code></h4> <p>ตามที่ Arch Wiki แนะนำ โดยย่อๆ คือเพิ่ม <code>extensions</code> (จำเป็น) และ <code>open_basedir</code> (ไม่ใส่ก็ได้แต่ผมใส่เพื่อความปลอดภัยครับ และถ้าคิดจะใส่แล้วก็ควรใส่ให้ครบครับ) ในไฟล์ <code>php.ini</code></p> <pre><code># &#47;etc&#47;php&#47;php.ini

[...]
extension=pdo_sqlite
[...]
extension=sockets
extension=sqlite3
[...]
open_basedir = &#47;srv&#47;http&#47;pihole:&#47;run&#47;pihole-ftl&#47;pihole-FTL.port:&#47;run&#47;log&#47;pihole&#47;pihole.log:&#47;run&#47;log&#47;pihole-ftl&#47;pihole-FTL.log:&#47;etc&#47;pihole:&#47;etc&#47;hosts:&#47;etc&#47;hostname:&#47;etc&#47;dnsmasq.d&#47;02-pihole-dhcp.conf:&#47;etc&#47;dnsmasq.d&#47;03-pihole-wildcard.conf:&#47;etc&#47;dnsmasq.d&#47;04-pihole-static-dhcp.conf:&#47;var&#47;log&#47;lighttpd&#47;error.log:&#47;proc&#47;meminfo:&#47;proc&#47;cpuinfo:&#47;sys&#47;class&#47;thermal&#47;thermal_zone0&#47;temp:&#47;tmp
</code></pre> <blockquote> <p><code>open_basedir</code> จะจำกัดการเข้าถึงไฟล์ซิสเต็มของ PHP ทำให้อุ่นใจว่าจะไม่มีโปรแกรม PHP ไปอ่านหรือเขียนไฟลฺ์นอกเหนือจาก path ที่กำหนดไว้ใน <code>open_basedir</code> ครับ</p> <p>บน VPS จะไม่มีโฟลเดอร์ <code>&#47;sys&#47;class&#47;thermal&#47;*</code> หากติดตั้ง Pi-Hole และเว็บอินเตอรฺ์เฟซบน VPS ผมไม่แนะนำให้ใส่ <code>&#47;sys&#47;class&#47;thermal&#47;thermal_zone0&#47;temp</code> ใน <code>open_basedir</code> ครับ</p> </blockquote> <h4 id=section-2><code>&#47;etc&#47;nginx</code></h4> <p>เขียนไฟล์ตั้งค่าเว็บเซอร์เวอร์ <code>nginx.conf</code> ซึ่งเราไปดูจาก <a href=https://wiki.archlinux.org/index.php/Pi-hole#Nginx_instead_of_Lighttpd>Arch Wiki</a> หรือจะดู<a href=https://docs.pi-hole.net/guides/webserver/nginx/ >ไกด์ของ Pi-Hole</a>เลยก็ได้ครับ หลักๆเลยคือเราจะแก้ไขไฟล์ตั้งค่า <code>nginx.conf</code> สำหรับการตั้งค่าทั่วไปของ NGINX และไฟลฺ์ <code>conf.d&#47;pihole.conf</code> สำหรับการตั้งค่า NGINX เพื่อเสริฟ Pi-Hole</p> <p>หลังจากเขียนไฟล์เสร็จแล้วเราต้อง<a href=https://wiki.archlinux.org/index.php/Pi-hole#Nginx_instead_of_Lighttpd>แก้ไขเซอร์วิสไฟล์ตาม Arch Wiki</a> สำหรับ PHP Fast Process Manager <code>php-fpm.service</code></p> <pre><code># systemctl edit php-fpm.service;
</code></pre> <p>แก้ไข (override) <code>php-fpm.service</code> ด้วยการเติม <code>ReadWritePaths</code> ไปในช่วง <code>[Service]</code> ซึ่งจะสัมพันธ์กับ <code>open_basedir</code> ใน <code>php.ini</code>:</p> <pre><code>[Service]
ReadWritePaths = &#47;srv&#47;http&#47;pihole
ReadWritePaths = &#47;run&#47;pihole-ftl&#47;pihole-FTL.port
ReadWritePaths = &#47;run&#47;log&#47;pihole&#47;pihole.log
ReadWritePaths = &#47;run&#47;log&#47;pihole-ftl&#47;pihole-FTL.log
ReadWritePaths = &#47;etc&#47;pihole
ReadWritePaths = &#47;etc&#47;hosts
ReadWritePaths = &#47;etc&#47;hostname
ReadWritePaths = &#47;etc&#47;dnsmasq.d&#47;
ReadWritePaths = &#47;proc&#47;meminfo
ReadWritePaths = &#47;proc&#47;cpuinfo
ReadWritePaths = &#47;sys&#47;class&#47;thermal&#47;thermal_zone0&#47;temp
ReadWritePaths = &#47;tmp
</code></pre> <blockquote> <p>บน VPS จะไม่มีโฟลเดอร์ <code>&#47;sys&#47;class&#47;thermal&#47;*</code> หากติดตั้ง Pi-Hole และเว็บอินเตอรฺ์เฟซบน VPS ผมไม่แนะนำให้ใส่ <code>&#47;sys&#47;class&#47;thermal&#47;thermal_zone0&#47;temp</code> ใน <code>ReadWritePaths</code> ครับ</p> </blockquote> <h2 id=enable-pi-hole-pi-hole-web-interface>Enable เซอร์วิสที่เกี่ยวกับ Pi-Hole และ Pi-Hole web interface</h2> <p>หลังจากแก้ไขทุกไฟล์เรียบร้อยครบทุกไฟล์ตาม Arch Wiki แล้ว เราก็ enable เซอร์วิสต่างๆทิ้งไว้ แล้วรีบูทครับ:</p> <pre><code class=language-shell>systemctl enable pihole-FTL.service nginx.service php-fpm.service;
reboot;
</code></pre> <blockquote> <p>ไม่ต้องรีบูทก็ได้นะครับ ใช้ <code>systemctl enable --now</code> แทนได้ หากไม่สามารถเริ่มเซอร์วิสได้ ให้ลองเช็ค Arch Wiki ซ้ำอีกรอบครับ ส่วนมากที่ผมพลาดจะเป็นการตั้งค่า PHP</p> </blockquote> <h2 id=pi-hole-dns>ตั้งค่า Pi-Hole DNS</h2> <p>พอบูทขึ้นมาเสร็จแล้ว ตั้งค่าพาสเวิร์ดของ admin web interface ด้วย:</p> <pre><code class=language-shell>pihole -a -p;
</code></pre> <p>แล้วตั้งค่า default DNS upstream ไปที่ listen address ของ <code>stubby</code>:</p> <pre><code class=language-shell>pihole -a setdns &#39;127.0.0.1#53690&#39;;
</code></pre> <p>แล้วอัพเดทบล็อคลิสต์ (gravity)</p> <pre><code class=language-shell>pihole -g;
</code></pre> <p>แก้ <code>&#47;etc&#47;resolv.conf</code> บนเครื่อง Pi-Hole ของเรา ให้ใช้ localhost พอร์ต 53 สำหรับ resolve โดเมน (address สำหรับเครื่องเราเองคือ <code>127.0.0.1</code> หรือ loopback address สำหรับเครื่อง Pi-Hole เองครับ):</p> <pre><code class=language-shell>echo &#39;127.0.0.1&#39; &#62; &#47;etc&#47;resolv.conf;
</code></pre> <p>หากคุณใช้ <code>openresolv</code> ผมคงไม่ต้องอธิบายว่าต้องทำยังไง ถูกไหมครับ? 5555</p> <h2 id=pi-hole-dns-web-interface>เริ่มใช้งาน Pi-Hole DNS และ web interface</h2> <p>เราสามารถเข้าถึง web interface ผ่าน web browser ที่ IP address ของ Pi-Hole ครับ ซึ่งถ้าหากคุณใช้ WireGuard ตามที่ผมแนะนำในข้อหนึ่ง คุณก็สามารถใช้ WireGuard IP address เพื่อโหลดหน้าเว็บผ่าน VPN ได้ครับ ลองเข้าไปเซ็ทอัพอะรดูก่อนครับ</p> <p>พอเสร็จแล้วก็ลอง query ไปที่ Pi-Hole ของเรา:</p> <pre><code class=language-shell>dig @localhost artnoi.com;
</code></pre> <p>หรือคิวรี่ผ่าน VPN ในที่นี่ขอสมมติว่า WireGuard IP ของ Pi-Hole คือ <code>10.0.0.1</code></p> <pre><code class=language-shell>dig @10.0.0.1 artnoi.com;
</code></pre> <p>โดยเราสามารถตั้งค่า WireGuard บนเครื่อง client ให้ใช้ DNS server เป็น Pi-Hole ได้ด้วยการเปลี่ยน <code>[Interface]: DNS = $PiHoleWGIP</code> เช่นในกรณีนี้ที่สมมติว่า WireGuard VPN network มี IP address เท่ากับ <code>10.0.0.0&#47;24</code>:</p> <pre><code>[Interface]
PrivateKey = eNf8P2Jx8UvBYLOmK2ToaUBrLNOpaByqWcv+GeWQ&#47;20=
Address = 10.0.0.2&#47;24
DNS = 10.0.0.1
</code></pre> <p>เพียงเท่านี้ ทุกครั้งที่คุณเชื่อมต่อเครือข่าย VPN ของคุณ เครื่องคุณก็จะใช้โฮสต์ 10.0.0.1 ที่มี Pi-Hole อยู่แล้ว ไว้ใช้เป็น Ad-blocking DNS sinkhole over VPN ครับ</p> <hr> <p><a href=#top>Back to top</a></p> <hr> <footer> <p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p> <p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p> </footer> </body> </html> 
<!DOCTYPE html><html lang=en> <head><title>Artnoi.com</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=keywords content="artnoi, Prem Phansuriyanon"><meta name=author content=@artnoi><meta charset=UTF-8><link href=/style.css rel=stylesheet></head> <body> <ul class=navbar> <li><a href=/ ><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li> <li class=f-right><a href=/cheat/ >cheat</a></li> <li class=f-right><a href=/blog/ >blog</a></li> <li class=f-right><a href=/about/ >about</a></li> </ul> <p>Aug 13, 2022</p> <h1 id=Hosting%20a%20HTTPS%20website%20with%20OpenBSD%20%3Ccode%3Ehttpd%3C/code%3E,%20and%20optionally%20%3Ccode%3Erelayd%3C/code%3E>Hosting a HTTPS website with OpenBSD <code>httpd</code>, and optionally <code>relayd</code></h1> <p><a href=/blog/2022/reset/ >After my old servers were compromised</a>, the first thing I do is to setup a new OpenBSD webserver. This makes sense, because of how OpenBSD is wonderfully suited for this task. The fact that the operating system ships with HTTP server, a well written <code>relayd(8)</code> for level-3 redirection and level-7 relays, a robust firewall (<code>pf(4)</code>), a robust VPN driver built into the kernel (<code>wg(4)</code>), and finally, a native ACME client <code>acme-client(1)</code>!</p> <p>Out of the box, OpenBSD is perfect right at the beginning for being a secure webserver! Ever since I first wrote the <a href=/blog/2020/openbsd-server/ >tutorial to create an OpenBSD webserver in 2020</a>, nothing (in the eye of the users) about the software has changed, but one thing has changed - I have more experience now. When I first wrote that article, I was not working in tech industry, did not write any programs other than shitty shell scripts, and tended to overengineer stuff.</p> <p>This time, it&#8217;ll be different. Everything will only be added if needed. Before we dive to the config files, let&#8217;s first discuss my desired HTTP server behavior.</p> <h2 id=Desired%20%3Ccode%3Ehttpd(8)%3C/code%3E%20behavior>Desired <code>httpd(8)</code> behavior</h2> <p>I want only 1 main virtual server, that is, <strong>there&#8217;ll be only 1 virtual server that does the actual serving of HTML files</strong>. Other virtual servers are for redirecting subdomains <strong>back to the main virtual servers</strong>.</p> <p>I also want <code>httpd(8)</code> to be somewhat more secure than my old front-end reverse proxy, NGINX. In OpenBSD, <code>httpd(8)</code> is run as user <code>www</code> by default. It does not matter if you run the webserver on the previleged ports or not - <code>httpd</code> will (by default) chroot <code>&#47;var&#47;www</code>, and will only see files in there. If <code>httpd</code> is compromised, then only the files user <code>www</code> has write permission to will be affected.</p> <p>My main requirement is to have subdomains, and all those subdomains share the same ACME certificate. All those subdomains are only for user convenience, and <code>httpd(8)</code> subdomain vurtual servers should redirect to the main virtual server.</p> <p>In the final stage, I want my webserver to</p> <ul> <li><p>Main webserver is on host <code>artnoi.com</code>, where we have the <code>root</code> directive for our HTML files.</p></li> <li><p>Redirect all HTTP traffic to HTTPS</p></li> <li><p>Handle HTTP ACME auth in <code>&#47;.well_known&#47;acme-challenge</code> despite other locations being redirected to HTTPS</p></li> <li><p>Redirect <code>www.artnoi.com</code> to <code>artnoi.com</code></p></li> <li><p>For subdomains other that <code>www</code>, do redirections like <code>cheat.artnoi.com&#47;foo</code> to <code>artnoi.com&#47;cheat&#47;foo</code></p></li> </ul> <h2 id=Using%20only%20%3Ccode%3Ehttpd(8)%3C/code%3E%20for%20standard%20HTTP>Using only <code>httpd(8)</code> for standard HTTP</h2> <p>You must first setup a simple webserver on your box and obtain ACME certificates&#47;key for your domain and subdomains. To do just that, setup a simple webserver just for ACME auth:</p> <pre><code># httpd.conf

prefork 5

# This virtual server can also handle ACME auth in HTTPS
server "artnoi.com" {
    alias "www.artnoi.com"
    alias "cheat.artnoi.com"
    alias "noob.artnoi.com"
    alias "zv.artnoi.com"

    listen on * port 80

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        root "&#47;acme"
        request strip 2
    }
}
</code></pre> <p>Now, configure <code>acme-client.conf(5)</code> such that we can use 1 ACME <em>fullchain</em> certificate for all subdomains:</p> <pre><code># acme-client.conf
authority letsencrypt {
    api url "https:&#47;&#47;acme-v02.api.letsencrypt.org&#47;directory"
    account key "&#47;etc&#47;acme&#47;letsencrypt-privkey.pem"
}

domain artnoi.com {
    alternative names { www.artnoi.com cheat.artnoi.com noob.artnoi.com zv.artnoi.com }
    domain key "&#47;etc&#47;ssl&#47;private&#47;artnoi.com.key"
    domain full chain certificate "&#47;etc&#47;ssl&#47;artnoi.com.crt"
    #domain certificate "&#47;etc&#47;ssl&#47;artnoi.com.crt"
    #domain full chain certificate "&#47;etc&#47;ssl&#47;artnoi.com.fullchain.pem"
    sign with letsencrypt
}
</code></pre> <p>Normally, <code>relayd</code> would look for the following keypair: <code>&#47;etc&#47;ssl&#47;private&#47;$name.key</code> and <code>&#47;etc&#47;ssl&#47;$name.crt</code>. But if we did not use <code>domain full chain certificate</code> as <code>&#47;etc&#47;ssl&#47;name.crt</code>, some clients like <code>curl</code> might complain that our certificate is not good enough. This is why re omitted <code>domain certificate</code>, and use <code>domain full chain certificate</code> for our <code>artnoi.com.crt</code> file.</p> <p>Now, start <code>httpd(8)</code> and run <code>acme-client(1)</code>:</p> <pre><code># httpd -n &#38;&#38; rcctl start httpd;
# acme-client -v artnoi.com;
</code></pre> <p>You can now proceed to setup a full HTTPS webserver if ACME challenge was successful and you got the certificates&#47;key configured in <code>acme-client.conf</code> in <code>&#47;etc&#47;ssl</code>.</p> <h2 id=Using%20only%20%3Ccode%3Ehttpd(8)%3C/code%3E%20to%20serve%20HTTPS>Using only <code>httpd(8)</code> to serve HTTPS</h2> <blockquote> <p>Note that the <code>root</code> directive is relative to <code>&#47;var&#47;www</code>.</p> </blockquote> <pre><code>prefork 5

public_interface = "vio0"
public_ip = "139.180.157.32"

types {
    # uncomment &#39;include&#39; line below to use all types
    # include "&#47;usr&#47;share&#47;misc&#47;mime.types"
    application&#47;pdf pdf
    image&#47;png       png
    image&#47;svg+xml   svg ico
    text&#47;css        css
    text&#47;html       html htm
    text&#47;plain      txt
}

# This virtual server "artnoi.com" is the main virtual HTTPS server
# to which all other subdomain virtual servers redirect to.
#
# This virtual server can also handle ACME auth in HTTPS
server "artnoi.com" {
    alias "www.artnoi.com"
    listen on $public_interface tls port 443
    root "&#47;htdocs&#47;www.artnoi.com"

    tls {
        certificate "&#47;etc&#47;ssl&#47;artnoi.com.fullchain.pem"
        key "&#47;etc&#47;ssl&#47;private&#47;artnoi.com.key"
    }
}

# This virtual "artnoi.com" server serves 2 purposes
# 1. Handle ACME auth for subdomains
# 2. Redirect non-ACME connection to HTTPS
#
# This virtual server is for "artnoi.com"&#47;"www.artnoi.com",
# so redirection simply returns https:&#47;&#47;$HTTP_HOST$REQUEST_URI.
server "artnoi.com" {
    alias "www.artnoi.com"
    listen on $public_interface port 80

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        root "&#47;acme"
        request strip 2
    }
    location * {
        block return 301 "https:&#47;&#47;$HTTP_HOST$REQUEST_URI"
    }
}

# These other subdomain virtual webservers are different than the one above,
# because we want to change the request host and URI too, and that new request
# should point to our main virtual server "artnoi.com" on 443.
#
# "http:&#47;&#47;cheat.artnoi.com&#47;foo" should be redirected to &#39;https:&#47;&#47;artnoi.com&#47;cheat&#47;foo&#39;
server "cheat.artnoi.com" {
    listen on $public_interface port 80

    # Redirect to the virtual server above for ACME challenges
    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }

    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;cheat$REQUEST_URI"
    }
}

# "http:&#47;&#47;noob.artnoi.com&#47;foo" should be redirected to &#39;https:&#47;&#47;artnoi.com&#47;noob&#47;foo&#39;
server "noob.artnoi.com" {
    listen on $public_interface port 80

    # Redirect to the virtual server above for ACME challenges
    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }

    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;noob$REQUEST_URI"
    }
}

# "http:&#47;&#47;zv.artnoi.com&#47;foo" should be redirected to &#39;https:&#47;&#47;artnoi.com&#47;noob&#47;foo&#39;
server "zv.artnoi.com" {
    listen on $public_interface port 80

    # Redirect to the virtual server above for ACME challenges
    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }

    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;noob$REQUEST_URI"
    }
}
</code></pre> <p>Now, while this configuration works, something is missing - we haven&#8217;t configure proper HTTP headers. This will leave both the users and servers vulnerable to man-in-the-middle or other attacks</p> <h2 id=Using%20%3Ccode%3Ehttpd(8)%3C/code%3E%20with%20%3Ccode%3Erelayd(8)%3C/code%3E%20to%20modify%20HTTP%20headers%20and%20TLS%20acceleration>Using <code>httpd(8)</code> with <code>relayd(8)</code> to modify HTTP headers and TLS acceleration</h2> <p>For our server to serve with secure HTTP request headers, we can use <code>relayd</code> to do that job. This means that, instead of having <code>httpd(8)</code> listening on port <code>80</code> and <code>443</code> for both HTTP and HTTPS request, we can use <code>relayd</code> as the frontend first (for both HTTP and HTTPS), and have it modify our HTTP headers as it relays the request to <code>httpd(8)</code>!</p> <p>For this, we need to</p> <ol> <li><p>Make <code>httpd(8)</code> listen on an internal HTTP address, e.g. <code>127.0.0.1:8888</code></p></li> <li><p>Set <code>relayd(8)</code> to listen on both 443 (TLS&#47;HTTPS) and 80 (HTTP), and forward the connections to <code>127.0.0.1:8888</code> where our <code>httpd(8)</code> is listening</p></li> </ol> <p>Let&#8217;s start with updating our <code>httpd.conf(5)</code> virtual server blocks to listen HTTP on <code>127.0.0.1:8888</code> instead:</p> <h3 id=Updating%20%3Ccode%3Ehttpd.conf(5)%3C/code%3E>Updating <code>httpd.conf(5)</code></h3> <blockquote> <p>Note: you can see that there&#8217;s no <code>tls</code> directive in <code>httpd.conf(5)</code> anymore.</p> </blockquote> <pre><code>prefork 5
this_server = "127.0.0.1"
internal_httpd_port = "8888"

types {
    # uncomment &#39;include&#39; line below to use all types
    # include "&#47;usr&#47;share&#47;misc&#47;mime.types"
    application&#47;pdf pdf
    image&#47;png       png
    image&#47;svg+xml   svg ico
    text&#47;css        css
    text&#47;html       html htm
    text&#47;plain      txt
}

server "artnoi.com" {
    alias "www.artnoi.com"
    listen on $this_server port $internal_httpd_port
    root "&#47;htdocs&#47;html-artnoi.com"

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        root "&#47;acme"
        request strip 2
    }
}

server "cheat.artnoi.com" {
    listen on $this_server port $internal_httpd_port

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }
    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;cheat$REQUEST_URI"
    }
}

server "noob.artnoi.com" {
    listen on $this_server port $internal_httpd_port

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }
    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;noob$REQUEST_URI"
    }
}

server "zv.artnoi.com" {
    listen on $this_server port $internal_httpd_port

    location "&#47;.well-known&#47;acme-challenge&#47;*" {
        block return 301 "http:&#47;&#47;artnoi.com$REQUEST_URI"
    }
    location * {
        block return 301 "https:&#47;&#47;artnoi.com&#47;noob$REQUEST_URI"
    }
}
</code></pre> <p>Restart <code>httpd(8)</code>. It should now be listening on port <code>8080</code>.</p> <h3 id=Updating%20%3Ccode%3Erelayd.conf(5)%3C/code%3E>Updating <code>relayd.conf(5)</code></h3> <p>One trick here is that we will not be specifying <code>tls keypair "artnoi.com"</code> here. This is because by default, <code>relayd(8)</code> looks for file <code>&#47;etc&#47;ssl&#47;private&#47;${ip_addr:port}.key</code> and <code>&#47;etc&#47;ssl&#47;{ip_addr:port}.crt</code> for each <code>listen</code> directive. Since we will have <code>relayd(8)</code> listen on public IP address <code>69.69.69.69</code>, we&#8217;ll have to symlink the private key and full chain certificate for the address.</p> <pre><code># # Use full chain cert (.pem) as 69.69.69.69.crt
# ln -s &#47;etc&#47;ssl&#47;{artnoi.com.fullchain.pem,69.69.69.69.crt}
# ln -s &#47;etc&#47;ssl&#47;private&#47;{artnoi.com,69.69.69.69}.key
</code></pre> <p>This will allow us to omit <code>tls keypair ..</code> in <code>relayd.conf(5)</code>. And after the webserver is running, we can now create a <code>relayd.conf</code> configuration that looks something like this:</p> <pre><code>public_interface = "69.69.69.69"
this_box = "127.0.0.1"

httpd_port = "8888"

table &#60;httpd&#62; { $this_box }
table &#60;dns_hosts&#62; { $this_box }

http protocol "httpfilter" {
    # set recommended tcp&#47;tls options
    tcp { nodelay, sack, socket buffer 65536, backlog 100 }
    tls { no tlsv1.2 }

    # Return HTTP&#47;HTML error pages to the client
    return error
    match header append "X-Forwarded-For" value "$REMOTE_ADDR"
    match header append "X-Forwarded-By" value "$SERVER_ADDR:$SERVER_PORT"
    match header append "Keep-Alive" value "$TIMEOUT"

    # See https:&#47;&#47;securityheaders.com to check and modify headers as needed below
    match response header remove "Server"
    match response header set "Content-Security-Policy" value "default-src &#39;self&#39;; style-src &#39;self&#39;; img-src &#39;self&#39;; base-uri &#39;self&#39;; frame-ancestors"
    match response header set "X-Frame-Options" value "deny"
    match response header set "X-XSS-Protection" value "1; mode=block"
    match response header set "X-Content-Type-Options" value "nosniff"
    match response header set "Referrer-Policy" value "no-referrer"

    match response header set "Feature-Policy" value "accelerometer &#39;none&#39;; camera &#39;none&#39;; geolocation &#39;none&#39;; gyroscope &#39;none&#39;; magnetometer &#39;none&#39;; microphone &#39;none&#39;; payment &#39;none&#39;; usb &#39;none&#39;"
    match response header set "Permissions-Policy" value "fullscreen=(), geolocation=(), microphone()"
    match response header set "Strict-Transport-Security" value "max-age=31536000; includeSubdomains; preload"

    match query hash "sessid"
    block path "&#47;cgi-bin&#47;index.cgi" value "*command=*"

    #pass request quick header "Host" value "artnoi.com" forward to &#60;httpd&#62;
    #pass request quick header "Host" value "www.artnoi.com" forward to &#60;httpd&#62;
    #pass request quick header "Host" value "cheat.artnoi.com" forward to &#60;httpd&#62;
    #pass request quick header "Host" value "noob.artnoi.com" forward to &#60;httpd&#62;
    #pass request quick header "Host" value "zv.artnoi.com" forward to &#60;httpd&#62;
    #pass request quick header "Host" value "chat.example.com" forward to &#60;synapse&#62;
}

relay "www4secure" {
    listen on $public_interface port 443 tls
    protocol httpfilter
    forward to &#60;httpd&#62; port $httpd_port mode loadbalance check tcp
}

relay "www4" {
    listen on $public_interface port 80
    protocol httpfilter
    forward to &#60;httpd&#62; port $httpd_port mode loadbalance check tcp
}
</code></pre> <p>With these configurations, <code>relayd(8)</code> now acts as both TLS accelerator, HTTP headers filter, and reverse HTTP proxy for <code>httpd(8)</code>. We can replicate the backend webservers a lot of times, and all we have to do is to add newer webservers to our <code>relayd.conf(5)</code> in the table <code>&#60;httpd_servers&#62;</code>.</p> <h2 id=Misc.>Misc.</h2> <p>You can check validity of your configurations with <code>-n</code> flag, e.g. <code>httpd -n</code>, which will test the default <code>&#47;etc&#47;httpd.conf</code>. To test a specific file, you can combine <code>-n</code> with <code>-f</code>, e.g. <code>relayd -n -f &#47;etc&#47;relayd-ng.conf</code>.</p> <h3 id=Wireguard%20VPN>Wireguard VPN</h3> <p>Since OpenBSD ships with <code>wg(4)</code>, we can basically write a <code>hostname.if(5)</code> file and create the network interface for our Wireguard connection. In this example, I&#8217;ll be using <code>wg1</code>, so the configuration file is <code>&#47;etc&#47;hostname.wg1</code>:</p> <pre><code># &#47;etc&#47;hostname.wg1
# Interface configuration
wgkey 6HTy5ej5gg2nN4rocwhinQx+XtIQ9SDa7vH3dIfTr1E=
wgport 6969
inet 192.168.69.1&#47;24
up

# Wireguard peers
!ifconfig wg1 wgpeer wizxPD&#47;5eTb0qyEx2uHtWCPDZ9EM4aLVLX4JcW4ui2k= wgendpoint 10.10.0.1 51543 wgaip 192.168.69.2&#47;32
!ifconfig wg1 wgpeer d4hwbjlHKlUE6kyq&#47;4ZEKnroD6LDfetE8op6bUk6KGo= wgpsk 6ibR&#47;T+WzbztlqdPKVs5Nbho7Q&#47;riD3Hy1rNEKPuD+0= wgaip 192.168.69.3&#47;32
</code></pre> <hr> <p><a href=#top>Back to top</a></p> <hr> <footer> <p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p> <p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p> </footer> </body> </html> 
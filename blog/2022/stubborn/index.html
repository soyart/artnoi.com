<!doctype html><html lang=en><head><title>Artnoi.com - Introducting [stubborn resolver](https://github.com/soyart/stubborn)</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet></head><body><ul class=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><p>April 13, 2022</p><h1 id=introducting-stubborn-resolver-https-github-com-soyart-stubborn>Introducting <a href=https://github.com/soyart/stubborn>stubborn resolver</a></h1><p>So after 6 months into this new software engineering job, I finally managed to balance my work with my schedule. As a result, I have had much more free (and high quality) time.</p><p>One of the things I usually do in these available moments is to <strong>distract myself from work by working on my own code</strong>. This greatly helps me gain coding and designing experience.</p><p>And last month, I began working on my new Go project - an attempt to imitate <a href=https://dnsprivacy.org/dns_privacy_daemon_-_stubby/>stubby</a> (I have been using <code>stubby</code> since like 2019 or 2020), but this time with caching!</p><h2 id=what-is-stubborn-and-how-do-i-use-it>What is stubborn and how do I use it?</h2><p>stubborn is a <em>caching</em> DNS stub resolver, with only <a href=https://en.wikipedia.org/wiki/DNS_over_TLS>DoT</a> or <a href=https://en.wikipedia.org/wiki/DNS_over_HTTPS>DoH</a> outgoing traffic. This is done to protect user privacy and for fun. It uses in-memory key-value cache, and can read UNIX-style <code>/etc/hosts</code> file or a <a href=https://github.com/soyart/stubborn/blob/main/config/table.json.example>proprietary JSON hosts file</a> for local network lookup table.</p><h3 id=installing-stubborn>Installing stubborn</h3><p>Assuming that you already have Go installed on your system, you can just use <code>go install</code> to install <code>stubborn</code> to your <code>bin</code> directory:</p><pre><code class=language-shell>go install github.com/soyart/stubborn/cmd/stubborn@latest
</code></pre><p>The above command should install <code>stubborn</code> executable in <code>$HOME/go/bin</code>, and pulls any build time depedencies down with it. If running <code>stubborn</code> is what you want, the command above should be enough. Just be sure to add the <code>bin</code> directory to your shell <code>$PATH</code>.</p><p>If you only want the source code, use <code>go get</code>:</p><pre><code class=language-shell>go get github.com/soyart/stubborn/cmd/stubborn@latest
</code></pre><p>After you have saw and finished cursing <code>stubborn</code> source code, you can build it with:</p><pre><code class=language-shell>cd /tmp/stubborn # cd to your source root
go build ./cmd/stubborn
</code></pre><p>The above command will produce <code>stubborn</code> binary in your working directory.</p><p><code>stubborn</code> supports only 2 outbound protocols - DoT and DoH. To run stubborn with either, use <code>-c</code> flag (case-insensitive):</p><pre><code class=language-shell>stubborn -c dot # Will spawn DoT client
stubborn -c doh # Will spawn DoH client
</code></pre><h3 id=why-stubborn-is-so-huge>Why stubborn is so huge?</h3><blockquote><p>Short answer: <code>stubborn</code>, like the other 102% of all my projects, is written in Go, which is a statically compiled language.</p></blockquote><p>With static linking by default in Go, imported code gets compiled into <em>one big chunk of binary</em> plus some Go runtime code (e.g. the GC or garbage compiled). You can see the list of Go modules used in this project in its <a href=https://github.com/soyart/stubborn/blob/main/go.mod><code>go.mod</code> file</a>. I swear I tried to minimize the libraries used.</p><p>Static linking makes Go applications appear to have much larger disk footprint than a C program. However, although stubborn is ~10MB when built, it is actually much smaller than some other C-based DNS resolvers that uses a lot of dynamic linking.</p><p>And because by default nothing is dynamically linked in Go, you can run this application without having to worry about the depedencies.</p><h3 id=yeah-i-get-it-go-is-statically-linked-but-why-the-source-is-so-large>Yeah I get it, Go is statically linked, but why the source is so large?</h3><p>Well, it started out small, but I decided to restructure it according to uncle Bob&rsquo;s clean architecture. <code>stubborn</code> is also very easy to implement new features or new infrastructure, just like my other project <a href=https://github.com/soyart/todong>todong</a> which supports 2 data store types, and 4 web frameworks! All configurable with just a line in the config file.</p><p>This view is in stark contrast to my previously held view that software should be suckless, i.e. being minimalists and focus on peak efficiency. Now I don&rsquo;t enjoy reading hacky code that&rsquo;s fast but configurable. Today I enjoy code than can be maintained and picked up by others easily. And extensibility (which means proper isolation) is now one of my top priorities.</p><h3 id=configuring-stubborn>Configuring stubborn</h3><p>I intend to replace stubby with stubborn in some of my machines, so I decided to prefix the configuration path at <code>/etc/stubborn</code>. This makes my life easier when configuring my spaghetti server services.</p><p>There are 2 files - (1) <code>/etc/stubborn/config.yaml</code> and (2) <code>/etc/stubborn/table.json</code>. These default locations can be changed in <code>/cmd/etc.go</code>.</p><p><code>config.yaml</code> configures stubborn behaviors, and <code>table.json</code> supplies stubborn with a key-value table to be used as local network domain lookup table.</p><h3 id=running-stubborn>Running stubborn</h3><p>If stubborn is in your path, just run <code>$ stubborn</code>. If <code>$GOPATH/bin</code> is not in your <code>$PATH</code>, you can <code>cd</code> to <code>$GOPATH/bin</code> and just run <code>./stubborn</code>.</p><p>Either way, this is stupid. Who the fuck would launch this command every time a system comes up? That&rsquo;s because as of this writing, I have not packaged stubborn as service yet. It&rsquo;s just a Go program now, though in the future I plan to include a systemd unit file for stubborn.</p><p>So now, just bear with it and run it in the old-fashioned way.</p><h2 id=why-dns-resolver>Why DNS resolver?</h2><p>I&rsquo;ll admit it - the first geeky thing that drew me to tech was setting up my own DNS resolvers as ads blockers. During 2019-2020, I had been crazy with setting up <em>my own</em> DNS servers everywhere.</p><p>On most of my Linux computers, I usually have three (yes, 3) DNS programs running to meet my goals, which is predominantly ads blocking (and some privacy concerns).</p><p>Before <code>stubborn</code>, my DNS server setup usually looks like this:</p><pre><code>dnsmasq[:53] -&gt; pihole[:5369] -&gt; stubby[:6953] -&gt; 1.1.1.1
&lt;listens&gt;       &lt;blocks ads&gt;     &lt;outgoing&gt;     &lt;upstream&gt;
</code></pre><p>So I use the caching resolver <code>dnsmasq</code> on the standard port 53 as the listener. This is where my other client computers ask and get replies from.</p><p>From there, <code>dnsmasq</code> in turn asks <code>pihole</code>, which acts as a blackhole for shitty domain names. <code>pihole</code> also has caching feature, because <code>pihole</code> is actually <code>dnsmasq</code> + ad blocking + web UI (if you installed it).</p><p>You can actually have <code>pihole</code> asks the upstreams for answers, but unfortunately, <code>pihole</code> did NOT support encrypted outbound queries at the time when I was a DNS simp, which is a big no-no for me. Here comes stubby - a non-caching privacy-first DNS resovler with DNSSEC support. I&rsquo;ve been very happy with <code>stubby</code>, so I just gave up on having encrypted outbound traffic from <code>pihole</code>.</p><p>People usually say that they can just use <code>systemd-resolved</code> or some NetworkManager plugins for this to work, but I really hate working with those Linuxy software from RedHat. These <em>more integrated</em> Linux tools are actually very difficult to wrap your head around, and I feel like they are highly coupled. Using <code>dnsmasq</code> as NetworkManager&rsquo;s resolver requires you to edit a lot of config files and dig deep into each component, and the worst thing is they fuck with <code>/etc/hosts</code> or <code>/etc/resolv.conf</code>, which usually requires you to install stupid packages like <code>systemd-resolvconf</code> or <code>openresolv</code> just for managing these files.</p><p>This is why I prefer running these 3 separate simple DNS resolvers. All you need to do is configure the listen addresses and the upstream addresses for each program, and boom, they <em>just</em> work together perfectly.</p><p>In other words, I like to fuck with DNS, and that&rsquo;s why I wanted to try writing my own shitty version of <code>stubby</code>. I&rsquo;m testing <code>stubborn</code> on some of my home servers now, and so far it worked great I did not feel any differences compared to using <code>stubby</code>.</p><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>
<!DOCTYPE html><html lang=en> <head><title>Artnoi.com</title><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=keywords content="artnoi, Prem Phansuriyanon"><meta name=author content=@artnoi><meta charset=UTF-8><link href=/style.css rel=stylesheet></head> <body> <ul class=navbar> <li><a href=/ ><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li> <li class=f-right><a href=/cheat/ >cheat</a></li> <li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a></li> <li class=f-right><a href=/blog/ >blog</a></li> </ul> <p><a href=/blog/2024/ >Mar 9, 2024</a></p> <h1 id=oRm%20baD>oRm baD</h1> <blockquote> <p>Note: this blog post is mostly about SQL ORM</p> </blockquote> <p>After some years of programming web back-end and other services, I&#8217;ve come to think very negatively about ORM in general.</p> <p>I had no problems with ORM during my first 2 years in the industry. This is simply because most things I did with SQL back then as a junior dev was very simple and straightforward. We rarely changed the SQL schemas, and when we did, it was easy.</p> <p>All that changed when I went on to work in a bank with very weird Oracle SQL and schemas designed by stupid BAs who thought they were smart after taking a business people&#8217;s SQL course.</p> <h2 id=What%20made%20ORM%20attractive?>What made ORM attractive?</h2> <p>To most newbie programmers, ORM seems like the right choice.</p> <p>We were taught that programming is about abstraction, and that abstraction is programming. And so we believed that we should stop worrying about database interaction.</p> <p>In Go, I was attracted to gorm the fact that I could just declare my SQL table schema as well as its cardinality in the struct type definition.</p> <p>I had somehow managed to avoid learning advanced SQL for 2 years, simply because my 1st company did not use much SQL. Plus when I had to, I told myself I could just use ORM.</p> <h2 id=ORM%20is%20complex>ORM is complex</h2> <p>Each ORM frameworks are <em>incredibly</em> complex, and generally come with opinionated assumptions about how they are going to be used.</p> <p>They also hide something from us. For example, most ORMs will do a <code>SELECT *</code> even if we only ask it to fetch a single column. We will never know about this from code alone, <em>unless we log the actual queries</em>.</p> <p>This obscurity is bad when debugging performance issues because simply scanning through code will mislead us to think innocently that our app only fetches a field.</p> <p>It also gets more complex with complex queries with multiple joins. Since we&#8217;ll have to do this when we declare our <em>ORM data models</em>, it gets even harder to analyze a large graph of data models with complex relationship.</p> <p>It gets worse when dealing with some niche or legacy databases, since these DBMS may have some platform-specific grammar. Some of these grammar is so niche that the driver the ORMs use don&#8217;t even support it, or the support is half-assed.</p> <p>This makes injecting these DBMS-specific dialect clauses very difficult when using ORM, even though most ORMs already provide features like <code>Suffix</code>, etc.</p> <p>When using ORM, the most fine-grained controls of these SQL executions are usually done using some of these <code>Suffix</code> stuff.</p> <p>Another reason that ORM needlessly increases complexity for our code is that ORM usually comes with framework-specific way to define database interactions. Adding another &#8220;language&#8221; (the ORM definitions) is of course going to make our code require more context to read.</p> <h2 id=ORM%20is%20not%20standardized>ORM is not standardized</h2> <p>Sometimes at my previous company, we needed to make changes to database code. Most of the times it&#8217;s due to race condition, or new features needed complex queries.</p> <p>Every time such problems came, the first thing I did was going to the ORM documentation.</p> <p>This is because different ORM frameworks have different APIs, and I never memorize ORM APIs because they aren&#8217;t standardized and will change arbitarily.</p> <p>This is worlds away from SQL specs, which are stable and are actually worth time for learning.</p> <p>Some RDBMS also has its own flavor of SQL, but the most basic operations are standardized, and this knowledge can be carried over or translated to other RDBMS. The stuff that differs tends to be advanced queries, like sub-queries, concurrency and transactions.</p> <p>This means that to properly use an RDMS, you&#8217;d first need to know SQL, and then the DMBS-specific details, in order to be able to build a correct, complex, performant queries.</p> <p>That may sound like a lot of work, but if you wish to do the same with ORM, <strong>you will still need to know the stuff that RDBS users know, plus, the details of your ORM framework!</strong></p> <p>This is because, whether with or without ORM, we can&#8217;t come up with complex queries without knowing SQL and the DMBS-specific details.</p> <p>So when problems get complex, you&#8217;ll still need to know SQL.</p> <h2 id=What%20then%20if%20ORM%20is%20bad?>What then if ORM is bad?</h2> <p>The answer is, just learn SQL. Knowing SQL will save time when debugging or programming a complex database interaction code.</p> <p>But using raw SQL in code is frowned upon, because the risk of SQL injection. To mitigate this, we usually use <em>SQL query builders</em> to help construct the safe, raw SQL strings.</p> <p>Query builders are ubiquitous, and most languages have &#62;1 such libraries. But sometimes the builders do not support all the things we want to do. What then?</p> <h2 id=Custom%20query%20builder>Custom query builder</h2> <p>The answer is homebrewed query builder! We can write a small query builder whose output can be used to inject to the builder libraries!</p> <p>And since the API of it all is just strings, we can simply develop the builder while printing to console to verify it works.</p> <p>This gives us freedom to generate complex queries for any RDBMS, with all the controls. We can even write separate builders for each DBMS if our queries are super complex.</p> <p>Some examples of custom query builder <a href=https://github.com/soyart/gsl/tree/master/sqlquery>is this</a> I wrote it because insert many rows on Oracle DB is PITA, and I&#8217;d been using it in production for a bank in Thailand for a while.</p> <p>It was paired with <a href=https://github.com/Masterminds/squirrel>squirrel</a> library, and only used when the squirrel does not support what I&#8217;m doing, or when hacking squirrel seems unintuitive.</p> <h2 id=Conclusion>Conclusion</h2> <blockquote> <p>ORM is okay for quick prototyping though</p> </blockquote> <p>ORM is bad, and relying on it long-term is not a safe path.</p> <p>First of all, if you solely relied on ORM without knowing SQL, you&#8217;ll be screwed once future changes need to do complex queries.</p> <p>Knowing SQL is a must - there&#8217;s no excuse for that. And we can then use that knowledge to write code using query builder libraries.</p> <p>If the builder libraries do not cover what you&#8217;re doing, you can just write a custom one to handle that part.</p> <hr> <p><a href=#top>Back to top</a></p> <hr> <footer> <p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p> <p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p> </footer> </body> </html> 
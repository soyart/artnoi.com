<!doctype html><html lang=en><head><title>Device mapper cheat sheet</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="artnoi,Prem Phansuriyanon"><meta name=author content="@artnoi"><meta charset=UTF-8><link href=/style.css rel=stylesheet></head><body><ul class=navbar><li><a href=/><img src=/toplogo.png alt=Artnoi.com class=logo>artnoi</a></li><li class=f-right><a href=/cheat/>cheat</a></li><li class=f-right><a href=https://notes.artnoi.com/#/all-pages>notes</a></li><li class=f-right><a href=/blog/>blog</a></li></ul><h1 id=device-mapper-cheat-sheet>Device mapper cheat sheet</h1><p>The Linux kernel <a href=https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/index.html>device mapper</a> framework (DM, or <code>dm</code>) includes support for <a href=http://www.sourceware.org/lvm2>LVM</a> (LVM2), a logical volume manager, and <a href=https://gitlab.com/cryptsetup/cryptsetup>LUKS</a>, a disk encrpytion specification that extends beyond <code>dm-crypt</code> present in the DM framework. <a href=#install>Jump to root on LVM and LUKS here</a></p><h2 id=lvm-lvm2>LVM (LVM2)</h2><p>Just like like any volume managers, Linux LVM is used to create multiple logical partitions out of a single hardware disk, or vice-versa. It adds a thin-provisioning layer above the hardware storage device itself, allowing for ease of use and administration. When compared to LUKS, LVM is harder to understand because it introduces 3 more concepts of storage: physical volumes (<code>pv</code>), volume groups (<code>vg</code>), and the logical volumes (<code>lv</code>), especially for novice computer users.</p><blockquote><p>We first initialize our storage hardware (physical volume, <strong>PV</strong>) for use by LVM with <code>pvcreate(8)</code>, then create a <em>logical</em> volume group <strong>VG</strong> on that <strong>PV</strong> with <code>vgcreate(8)</code>, and lastly we create a logical volume <strong>LV</strong> on that <strong>VG</strong> with <code>lvcreate(8)</code>.</p></blockquote><h2 id=luks-luks2>LUKS (LUKS2)</h2><p>LUKS provides disk encryption specification that extends beyond plain <code>dm-crypt</code>. Most notably, it provides an encryption header which in my case is useful for administration.</p><blockquote><p>Use <code>cryptsetup(8)</code> to setup plain <code>dm-crypt</code> or LUKS2 <code>dm-crypt</code> on your storage.</p></blockquote><p>When LVM and LUKS are used together, the device mapper framework is able to provide flexible and secure storage solutions for both data storage and the root filesystems. For root filesystems, the boot process must be changed to accomodate the unlocking and unpacking of the device mapper(s). Other alternatives include kick-ass filesystems like ZFS, which also provides logical volume manager, encryption, as well as the filesystem itself.</p><h2 id=frequently-used-cryptsetup-commands>Frequently used <code>cryptsetup</code> commands</h2><p>Create a LUKS device:</p><pre><code class=language-shell>cryptsetup luksFormat &lt;DEVICE&gt;;
cryptsetup luksFormat /dev/sdXY;
</code></pre><p>Opening a LUKS device</p><pre><code class=language-shell>cryptsetup luksOpen &lt;DEVICE&gt; &lt;DEVICE MAPPER NAME&gt;;
cryptsetup luksOpen /dev/sdXY myluks;
</code></pre><p>Closing a LUKS device</p><pre><code class=language-shell>cryptsetup luksClose &lt;DEVICE MAPPER NAME&gt;;
cryptsetup luksClose myluks;
</code></pre><p>Dump LUKS information (e.g. key slots):</p><pre><code class=language-shell>cryptsetup luksDump &lt;DEVICE&gt;;
cryptsetup luksDump /dev/sdXY;
</code></pre><p>Backup LUKS header to a file:</p><pre><code class=language-shell>cryptsetup luksHeaderBackup &lt;DEVICE&gt; --header-backup-file &lt;HEADER FILE&gt;;
cryptsetup luksHeaderBackup /dev/sdXY --header-backup-file sdXY.header;
</code></pre><p>Restore LUKS header:</p><pre><code class=language-shell>cryptsetup luksHeaderRestore &lt;DEVICE&gt; --header-backup-file &lt;HEADER FILE&gt;;
cryptsetup luksHeaderRestore /dev/sdXY --header-backup-file sdXY.header;
</code></pre><p>Adding LUKS key:</p><pre><code class=language-shell>cryptsetup luksAddKey &lt;DEVICE&gt;;
cryptsetup luksAddKey /dev/sdXY;
</code></pre><p>Removing LUKS key (in this example, slot 12):</p><pre><code class=language-shell>cryptsetup luksKillSlot &lt;DEVICE&gt; &lt;KEY SLOT&gt;;
cryptsetup luksKillSlot /dev/sdXY 12;
</code></pre><p><a name=install></a></p><h2 id=installing-linux-root-on-luks-on-lvm>Installing Linux root on LUKS-on-LVM</h2><h3 id=partitioning-and-setting-up-device-mapper>Partitioning and setting up device mapper</h3><blockquote><p>For many reasons including performance, <strong>I recommend LUKS-on-LVM over LVM-on-LUKS</strong>. If you want to use LVM-on-LUKS instead, just reverse the steps: create LUKS devices on hardware partitions first and later create LVM devices on top of LUKS. The <code>mkinitcpio</code> hooks are identical for both setups.</p></blockquote><p>First, we create physical partitions with <code>fdisk</code>. You can use any partition editing tools you like though. We will use <code>sda</code> in this example, and <code>sda1</code> will be for our EFI System Partition, and <code>sda2</code> for LVM:</p><pre><code class=language-shell>fdisk /dev/sdX;
</code></pre><p>Create unencrypted <code>FAT32</code> for EFI (will be mounted at <code>/boot</code>):</p><pre><code class=language-shell>mkfs.vfat -F32 -L &quot;BOOT&quot; /dev/sda1
</code></pre><p>Create <em>physical volume</em> for LVM. We will later assign a volume group to this physical volume:</p><pre><code class=language-shell>pvcreate /dev/sda2;
</code></pre><p>Assign <em>volume group</em> to our physical volume:</p><pre><code class=language-shell>vgcreate mylvm /dev/sda2;
</code></pre><p>Create <em>logical volumes</em>:</p><pre><code class=language-shell>lvcreate -C y -L 16G -n cryptswap mylvm;
lvcreate -l 100%FREE -n cryptroot mylvm;
</code></pre><p>Encrypt the other partition, and then open it in <code>/dev/mapper</code>:</p><pre><code class=language-shell>cryptsetup luksFormat /dev/mylvm/cryptroot;
cryptsetup luksFormat /dev/mylvm/cryptswap;

cryptsetup luksOpen /dev/mylvm/cryptroot root;
cryptsetup luksOpen /dev/mylvm/cryptswap swap;
</code></pre><p>Now we should have our decrypted partition listed at <code>/dev/mapper/root</code> and <code>/dev/mapper/swap</code>.</p><p>Create filesystem(s) (<code>mkfs</code>, <code>mkswap</code>):</p><pre><code class=language-shell>mkfs.btrfs -L &quot;ROOT&quot; /dev/mapper/root;
mkswap -L &quot;SWAP&quot; /dev/mapper/swap;
</code></pre><h3 id=installing-linux>Installing Linux</h3><p>You can follow the distribution guide to encrypted root installation: <a href=https://wiki.voidlinux.org/Install_LVM_LUKS_on_UEFI_GPT>Void Linux guide</a>, <a href=https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system>Arch Linux guide</a>.</p><p>Unless my system fails to boot, I don&rsquo;t follow the guides. I simply encrypt a partition first, then install Arch Linux to it as usual, and lastly configure the boot process which (to me) is the only difference between an encrypted and plain installations. Below is how I usually setup Linux to boot into encrypted root.</p><h3 id=booting>Booting</h3><h5 id=ssd-users-may-want-to-look-this-a-href-https-wiki-archlinux-org-index-php-dm-crypt-specialties-discard-trim-support-for-solid-state-drives-ssd-arch-wiki-page-a-to-allow-discards-trim-https-wiki-archlinux-org-title-solid-state-drive-trim-on-dm-crypt-device>SSD users may want to look this <a href=https://wiki.archlinux.org/index.php/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)>Arch Wiki page</a> to allow <a href=https://wiki.archlinux.org/title/Solid_state_drive#TRIM>discards (TRIM)</a> on dm-crypt device</h5><p>Configure <code>/boot</code> accordingly. We will be using <code>sd-encrypt</code> (systemd) for Arch Linux:</p><pre><code class=language-shell>HOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt lvm2 filesystems resume fsck)
</code></pre><p>and regenerate the image(s):</p><pre><code class=language-shell>mkinitcpio -P;
</code></pre><p>Note that you can remove <code>lvm2</code> hook in <code>mkinitcpio.conf</code> if you only use LUKS, i.e. you don&rsquo;t use any LVM logical volumes. Alternatively, be sure to install <code>lvm2</code> package, and add <code>lvm2</code> hook in <code>mkinitcpio</code>, if you wish to install your root filesystem on logical volumes.</p><h4 id=configuring-boot-kernel-parameter>Configuring boot kernel parameter</h4><p>I use <code>systemd-boot</code> which reads boot kernel parameters from <code>/boot/loader/entries/*.conf</code>, but the parameters should also work on any boot loaders. The following example is tested on Arch Linux with <code>systemd-boot</code> only.</p><p>Also, <code>rd.luks.options=discard</code> is used in the examples. Read <a href=https://wiki.archlinux.org/index.php/Dm-crypt/Specialties#Discard/TRIM_support_for_solid_state_drives_(SSD)>this Arch Wiki for dm-crypt TRIM support</a> before considering adding the discard option.</p><p>Example 1: LUKS-on-LVM:</p><pre><code>options	loglevel=3
options	rd.luks.options=discard
options rd.luks.name=&lt;Root LVM UUID&gt;=cryptroot
options rd.luks.name=&lt;Swap LVM UUID&gt;=cryptswap
options	root=/dev/mapper/cryptroot ro
options	resume=/dev/mapper/cryptswap
</code></pre><p>Example 2: LVM-on-LUKS - in this example, the LVM volumes <code>root</code> and <code>swap</code> is within LVM volume group <code>cryptlvm</code>:</p><pre><code>options loglevel=3
options rd.luks.options=discard
options rd.luks.name=&lt;PART UUID&gt;=cryptlvm
options root=/dev/mapper/cryptlvm-root ro
options resume=/dev/mapper/cryptlvm-swap
</code></pre><p>Let&rsquo;s say from Example 2, the LVM UUID is <code>dddddd</code> (d is for disk not dick), and we want to <a href=https://wiki.archlinux.org/index.php/Dm-crypt/System_configuration#rd.luks.key>put the keyfile</a> to a flashdrive whose UUID is <code>ffffff</code> (f is for flash not fuck), then the kernel parameter should be:</p><pre><code>options loglevel=3
options rd.luks.options=discard
options rd.luks.name=dddddd=cryptlvm
options rd.luks.key=dddddd=&lt;Path to key file&gt;:UUID=fffffff
options root=/dev/mapper/cryptlvm-root ro
options resume=/dev/mapper/cryptlvm-swap

# Fallback to password if keyfile not found
#options rd.luks.options=dddddd=keyfile-timeout=10s
</code></pre><p>One important note is that if you choose to have a keyfile on other device, it must be of the same filesystem type as your root filesystem (e.g. EXT4) otherwise you will have to <a href=https://wiki.archlinux.org/index.php/Mkinitcpio#MODULES>include the kernel module for it in the initramfs</a>.</p><p>Example 3: Install on LUKS - in this example, the LUKS device has its own raw partition:</p><pre><code>options loglevel=3
options rd.luks.options=discard
options rd.luks.name=&lt;PART UUID&gt;=cryptroot
options rd.luks.name=&lt;PART UUID&gt;=cryptswap
options root=/dev/mapper/cryptroot ro
options resume=/dev/mapper/cryptswap
</code></pre><p>or if you use <code>grub</code> ( in <code>/etc/default/grub</code>):</p><pre><code>GRUB_CMDLINE_LINUX_DEFAULT=&quot;loglevel=3 rd.luks.options=discard rd.luks.name=UUID=cryptlvm \
    root=/dev/mapper/arch-root resume=/dev/mapper/arch-swap&quot;
</code></pre><p>If you use <code>grub</code>, <strong>create <code>grub.cfg</code> configuration file afterwards with new parameters</strong>, or you will boot to default <code>grub</code> loader that doesn&rsquo;t know how to handle your encrypted root fs:</p><pre><code class=language-shell>grub-mkconfig -o /boot/grub/grub.cfg;
</code></pre><h2 id=fedora-32-fstab>Fedora 32 <code>fstab</code></h2><p>If your Fedora 32 root option is LUKS-on-LVM option, then the volumes get unlocked and mounted by <code>plymouth.service</code>, which requires special device naming in <code>fstab</code> (literally: <code>/dev/mapper/luks-*UUID*</code>). <strong>Just use the device name provided by your installation <code>fstab</code>, because as of writing (Aug 4 2020), the value can NOT be replaced with the mountpoint&rsquo;s actual UUID</strong>, or you will boot into emergency mode complaining that the root is locked. Another note is that <code>noatime</code> and <code>nodiratime</code> will also fail your boot.</p><h2 id=closing-lvm-and-luks-devices>Closing LVM and LUKS devices</h2><p>Stopping LVM volume group:</p><pre><code class=language-shell>vgchange -a n ${your_vg_name};
</code></pre><p>You can switch it back on again using:</p><pre><code class=language-shell>vgchange -a y ${your_vg_name};
</code></pre><p>After switching off the volume group, you can close LUKS device with:</p><pre><code class=language-shell>cryptsetup luksClose ${your_LVM_name};
</code></pre><p>Enjoy!</p><hr><p><a href=#top>Back to top</a></p><hr><footer><p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p><p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p></footer></body></html>
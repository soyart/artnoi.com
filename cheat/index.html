<!DOCTYPE html>
<html lang="en">

<head>
  <title>Artnoi.com</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="keywords" content="artnoi, Prem Phansuriyanon">
  <meta name="author" content="@artnoi">
  <meta charset="UTF-8">
  <link href="/style.css" rel="stylesheet">
</head>

<body>
  <ul class="navbar">
    <li><a href="/"><img src="/toplogo.png" alt="Artnoi.com" class="logo">artnoi</a></li>
    <li class="f-right"><a href="/cheat/">cheat</a></li>
    <li class="f-right"><a href="https://notes.artnoi.com/#/all-pages">notes</a></li>
    <li class="f-right"><a href="/blog/">blog</a></li>
  </ul><h1 id="cheat-sheet-for-myself">Cheat sheet for myself</h1>

<p><a href="#others">Other cheat sheets</a> are also available</p>

<h2 id="combining-find-1-with-rm-1">Combining <code>find(1)</code> with <code>rm(1)</code></h2>

<p><code>find(1)</code> is a very powerful UNIX tool. This example shows how we can find
and remove unwanted files recursively:</p>

<pre><code class="language-shell">find &lt;PATH&gt; -name &lt;NAME&gt; -exec rm -f {} \;
</code></pre>

<p>The example below will recursively remove file(s) <code>.DS_Store</code>,
starting from the working directory:</p>

<pre><code class="language-shell">find . -name '.DS_Store' -exec rm -f {} \;
</code></pre>

<h2 id="using-lsof-to-discover-process-running-on-a-port">Using <code>lsof</code> to discover process running on a port</h2>

<pre><code class="language-shell"># macOS, and probably BSD
lsof -n -i TCP:6379;

# GNU/Linux
lsof -i :6379;
</code></pre>

<h2 id="posix-shell-parameter-expansion">POSIX shell parameter expansion</h2>

<p>People should know parameter expansion to avoid invoking (abusing) <code>cat(1)</code>,
<code>awk(1)</code>, <code>sed(1)</code>, and <code>grep(1)</code>.</p>

<p>However, when people use shell parameter expansion, they use non-POSIX syntax,
i.e. <code>bash</code>-specific syntax, which is not portable.</p>

<blockquote>
<p>The examples are for POSIX-compliant shell like UNIX <code>sh(1)</code> and <code>dash(1)</code>.
If you are using <code>bash(1)</code> and don&rsquo;t care about portability,
see <a href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html">reference manual for <code>bash(1)</code> shell</a>.
You can also see <code>dash</code> man pages for POSIX parameter expansion.</p>
</blockquote>

<h3 id="string-length">String length</h3>

<pre><code class="language-shell">FOO=&quot;foo&quot;;

echo ${#FOO}; # 3
</code></pre>

<h3 id="substring-prefix-removal-with">Substring: prefix removal with &lsquo;#&rsquo; (&lsquo;##&rsquo;)</h3>

<p>The variable name used in this demo will be <code>STR</code> with value <code>&quot;foobar&quot;</code>:</p>

<pre><code class="language-shell">STR='foobar';
</code></pre>

<p>Remove last 3 characters:</p>

<pre><code class="language-shell">echo ${STR#???}; # &quot;bar&quot;
</code></pre>

<p>Remove &lsquo;foo&rsquo; from start:</p>

<pre><code class="language-shell">echo ${STR#foo}; # &quot;bar&quot;
</code></pre>

<p>Remove &lsquo;fo&rsquo; (smallest pattern):</p>

<pre><code class="language-shell">echo ${STR#f*o}; # &quot;obar&quot;
</code></pre>

<p>Remove &lsquo;foo&rsquo; (largest pattern):</p>

<pre><code class="language-shell">echo ${STR##f*o}; # &quot;bar&quot;
</code></pre>

<h3 id="substring-suffix-removal-with">Substring: suffix removal with &lsquo;%&rsquo; (&lsquo;%%&rsquo;)</h3>

<p>The variable name used in this demo will be <code>STR</code> with value <code>&quot;foobar&quot;</code>:</p>

<pre><code class="language-shell">STR='foobar';
</code></pre>

<p>Remove first 2 characters</p>

<pre><code class="language-shell">echo ${STR%??}; # &quot;foob&quot;
</code></pre>

<p>Remove &lsquo;bar&rsquo; pattern from end:</p>

<pre><code class="language-shell">echo ${string%bar}; # &quot;foo&quot;
</code></pre>

<p>Remove pattern expands to &lsquo;obar&rsquo;:</p>

<pre><code class="language-shell">echo ${string%o*r}; # &quot;fo&quot;
</code></pre>

<p>Remove pattern expands to &lsquo;oobar&rsquo;:</p>

<pre><code class="language-shell">echo ${string%%o*r}; # &quot;f&quot;
</code></pre>

<p>The example below will move (i.e. rename) all files with <code>.text</code> extension to
<code>.txt</code> with a shell <code>for</code> loop (e.g. <code>token.text</code> -&gt; <code>token.txt</code>):</p>

<pre><code class="language-shell">for f in *&quot;.text&quot;;
do
    mv &quot;${f}&quot; &quot;${f%.text}.txt&quot;;
done;
</code></pre>

<p>The example below will move all files starting with substring <code>gh</code> to be
starting with <code>github</code> instead (e.g. <code>gh_key</code> -&gt; <code>github_key</code>):</p>

<pre><code class="language-shell">for f in &quot;gh&quot;*;
do
    mv &quot;${f}&quot; &quot;github${f#gh}&quot;;
done;
</code></pre>

<h3 id="substitution">Substitution</h3>

<p>I usually just use 2 of the many substitutions:</p>

<ul>
<li><p><code>${parameter:-word}</code> - use word as default value if <code>parameter</code> is null</p></li>

<li><p><code>${parameter:=word}</code> - assign word as default value if <code>parameter</code> is null</p></li>
</ul>

<p>These and their other variants are super-useful, and I wish I knew about these sooner.</p>

<p>Let&rsquo;s see some simple examples so you understand why these are useful:</p>

<pre><code class="language-shell">string0='test'; # string1 is still null
</code></pre>

<p>Use <code>string0</code> value if <code>string1</code> is null</p>

<pre><code class="language-shell"># string1 is still null

echo ${string1}; # no output

echo ${string1:-$string0}; # &quot;test&quot;
</code></pre>

<p>Assign <code>string0</code> value if <code>string1</code> is null</p>

<pre><code class="language-shell">echo ${string1:=$string0}; # ouputs &quot;test&quot;, as well as assign &quot;test&quot; to string1

echo ${string1}; # outputs &quot;test&quot;
</code></pre>

<h2 id="redirecting-shell-output">Redirecting shell output</h2>

<blockquote>
<p><code>2&gt;&amp;1</code> redirects stderr to stdout</p>
</blockquote>

<p>Discarding output and error messages:</p>

<pre><code class="language-shell">foo &gt; /dev/null 2&gt;&amp;1;
</code></pre>

<p>Writing to both stdout and file <code>out.txt</code>:</p>

<pre><code class="language-shell">foo 2&gt;&amp;1 | tee out.txt;
</code></pre>

<h2 id="using-dd-1">Using <code>dd(1)</code></h2>

<p>Writing a disk image from <code>image.iso</code> to USB flash drive <code>/dev/sdc</code>:</p>

<pre><code class="language-shell">dd bs=4M if=image.iso of=/dev/sdc status=progress oflag=sync;
</code></pre>

<p>Writing a key file with 2048 random bytes from special random character device <code>/dev/random</code>:</p>

<blockquote>
<p>In this case, use of <code>/dev/random</code> is <a href="https://man7.org/linux/man-pages/man4/random.4.html">prefered</a> over <code>/dev/arandom</code> and <code>/dev/urandom</code>.</p>
</blockquote>

<pre><code class="language-shell">dd bs=512 count=4 if=/dev/random of=&lt;DEST&gt; iflag=fullblock;
</code></pre>

<p>If you want a 4096-byte-long key file, use <code>count=8</code>.</p>

<h2 id="mounting-disk-images">Mounting disk images</h2>

<p>On <em>modern</em> GNU/Linux systems, we can mount partition images with option <code>loop</code>:</p>

<pre><code class="language-shell">mount -o loop image.iso /mnt;
</code></pre>

<h2 id="macos">macOS</h2>

<h3 id="updatedb-on-macos"><code>updatedb</code> on macOS</h3>

<pre><code class="language-shell">sudo /usr/libexec/locate.updatedb;
</code></pre>

<h3 id="modifying-macos-system-files">Modifying macOS system files</h3>

<p>As of Catalina (10.15), the system files reside in their own encrypted read-only partition.</p>

<p>So if you wish to modify system files, disabling SIP alone is not enough - you will also have to remount the system partition with <em>write</em> permission:</p>

<pre><code class="language-shell">mount -uw / &amp;&amp; killall Finder;
</code></pre>

<h3 id="macos-native-ramdisk-hfs">macOS native ramdisk (HFS+)</h3>

<p>Ramdisks are perfect for temporary storage. I have had a habit where I edit my text files exclusively in <code>/tmp</code>.</p>

<p>It&rsquo;s a shame OS X does <em>not</em> ship with tmpfs OOTB. Nonetheless, we can still create a HFS+ ramdisk (of size 4GB) using utilities from the base install:</p>

<pre><code class="language-shell">diskutil erasevolume HFS+ 'RAM Disk' `hdiutil attach -nomount ram://8388608`;
</code></pre>

<p>Yes, the 5th argument is in back ticks.</p>

<blockquote>
<p>Hint: use the following value to specify block size: 524288 for 256MB, 1048576 for 512MB, 2097152 for 1GB, 4194304 for 2GB.</p>
</blockquote>

<h2 id="nfs-related">NFS-related</h2>

<h3 id="windows-10-pro-nfs-client">Windows 10 Pro NFS client</h3>

<p>You must first enable NFS client. You can do it in Powershell with:</p>

<pre><code class="language-PowerShell">Enable-WindowsOptionalFeatures -FeatureName ServicesforNFS-ClientOnly, ClientForNFS-Infrastructure -Online -NoRestart
</code></pre>

<p>Or from Control Panel &gt; &ldquo;Programs&rdquo; &gt; &ldquo;Turn Windows features on or off&rdquo; &gt; &ldquo;Services for NFS&rdquo; &gt; &ldquo;Client for NFS&rdquo;.</p>

<p>After you enabled NFS client, you can just use File Explorer to go to your remote location, e.g. <code>\\10.8.0.1\myshare</code> or use <code>NewPSDrive</code> to mount the NFS share:</p>

<pre><code class="language-PowerShell">New-PSDrive -Name &quot;Z&quot; -Root &quot;\\10.8.0.1\myshare&quot; -Persist -PSProvider &quot;Filesystem&quot;
</code></pre>

<p>Or use <code>mount</code> (which is alias to <code>New-PSDrive</code>) and fill up the argument by line.</p>

<p><code>Name</code> is desired Windows drive letter, and <code>Root</code> is the remote location, e.g.:</p>

<pre><code class="language-shell">mount
Name: Z
PSProvider: Filesystem
Root: \\10.8.0.1\myshare
</code></pre>

<p>You can list the shares with <code>Get-PSDrive</code> and unmount it with <code>Remove-PSDrive</code>.</p>

<h3 id="openbsd-nfs-client">OpenBSD NFS client</h3>

<p>Try mounting with option <code>-o tcp</code>. Also, recheck export list on the host, e.g. <code>foo</code>: <code>showmount -e foo</code>, and make sure to have NTP time sync enabled with the correct timezone.</p>

<h2 id="openbsd-configuraton">OpenBSD configuraton</h2>

<h3 id="hostname-if-5-https-man-openbsd-org-hostname-if-5-for-wg-4-https-man-openbsd-org-wg-wireguard-point-to-point-connection"><a href="https://man.openbsd.org/hostname.if.5">hostname.if(5)</a> for <a href="https://man.openbsd.org/wg">wg(4)</a>: WireGuard point-to-point connection</h3>

<p>See also: <a href="https://artnoi.com/blog/2020/wireguard/">WireGuard on OpenBSD</a>.</p>

<pre><code># Interface configuration
wgkey yourPrivKey=
wgport 6969
inet 10.8.1.4/24
up

# WireGuard peers
!ifconfig wg0 wgpeer peer1pubkey= wgendpoint 192.168.2.3 5555 wgaip 10.8.1.1/32
!ifconfig wg0 wgpeer peer2pubkey= wgendpoint example.com 9696 wgaip 10.8.1.2/32
!ifconfig wg0 wgpeer peer3pubkey= wgaip 10.8.1.3/32
</code></pre>

<h3 id="pf-conf-5-https-man-openbsd-org-pf-conf-for-wg-4-https-man-openbsd-org-wg"><a href="https://man.openbsd.org/pf.conf">pf.conf(5)</a> for <a href="https://man.openbsd.org/wg">wg(4)</a></h3>

<pre><code># pf.conf(5) for WireGuard

pass in on egress inet proto udp\
    from any to any port 6969

pass out on egress inet\
    from (wg0:network) nat-to (egress:0)
</code></pre>

<h3 id="relayd-conf-5-https-man-openbsd-org-relayd-conf-5-relaying-ssh-connection"><a href="https://man.openbsd.org/relayd.conf.5">relayd.conf(5)</a>: relaying SSH connection</h3>

<pre><code>protocol &quot;myssh&quot; {
    tcp {
        nodelay
        socket buffer 65536
    }
}

relay &quot;sshforward&quot; {
    listen on www.example.com port 2222
    protocol &quot;myssh&quot;

    forward to shell.example.com port 22
}
</code></pre>

<h3 id="relayd-conf-5-https-man-openbsd-org-relayd-conf-5-redirecting-dns-connection"><a href="https://man.openbsd.org/relayd.conf.5">relayd.conf(5)</a>: redirecting DNS connection</h3>

<pre><code>redirect &quot;dns&quot; {

  listen on dns.example.com\
    tcp port 53

  listen on dns.example.com\
    udp port 53

  forward to &lt;dnshosts&gt;\
    port 53 check tcp
}
</code></pre>

<h3 id="httpd-8-with-tls-https">httpd(8) with TLS (HTTPS)</h3>

<p>See <a href="/blog/2020/openbsd-server/">this blog</a>.</p>

<h3 id="installing-openbsd-with-full-disk-encrpytion-on-vultr-https-vultr-com">Installing OpenBSD with full-disk encrpytion on <a href="https://vultr.com">Vultr</a></h3>

<p>See <a href="/blog/2020/openbsd/">this blog</a>.</p>

<h2 id="gnu-linux-only">GNU/Linux only</h2>

<h3 id="systemd-drop-in-configuration">systemd drop-in configuration</h3>

<p>Drop-ins are parsed and overrides global configuration. The files are read alphabetically, so file <code>00-override</code> loads before <code>100-override</code>, i.e. <code>00</code> is overridden by <code>100</code>.</p>

<h3 id="systemd-service-failure">systemd service failure</h3>

<p>If <code># systemctl status</code> returned <em>degraded</em>, we can issue:</p>

<pre><code class="language-shell">systemctl reset-failed;
</code></pre>

<p>to fix the failed units.</p>

<h3 id="systemd-journald-auth-log">systemd (journald) auth.log</h3>

<pre><code class="language-shell">journalctl SYSLOG_FACILITY=10;
</code></pre>

<h3 id="persistent-iptables-dropping-incoming-traffic">Persistent <code>iptables</code> dropping incoming traffic</h3>

<p>On Arch Linux, Systemd service <code>iptables.service</code> will load configuration <code>/etc/iptables/ipatbles.rules</code> on startup if the service is enabled. The file originally has blank fules.</p>

<p>To configure <code>iptables</code> such that it drops all incoming connections (in a usable way), change the configuration to:</p>

<blockquote>
<p>From <a href="https://superuser.com/questions/427458/deny-all-incoming-connections-with-iptables">superuser.com</a></p>
</blockquote>

<pre><code>*filter

:FORWARD DROP [0:0]

:OUTPUT ACCEPT [623107326:1392470726908]

:INPUT DROP [11486:513044]

-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

-A INPUT -i lo -j ACCEPT

-4 -A INPUT -p icmp -j ACCEPT
-6 -A INPUT -p ipv6-icmp -j ACCEPT

# Add exception rules here
#-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT
#-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
#-A INPUT -p tcp -m tcp --dport 443 -j ACCEPT

COMMIT
</code></pre>

<p>Also, enable the service (otherwise you would have to use <code>iptables-restore</code> each time you reboot):</p>

<pre><code class="language-shell">systemctl enable --now iptables;
</code></pre>

<h3 id="changing-storage-device-designation-e-g-sdx1-to-sdx4">Changing storage device designation, e.g. sdX1 to sdX4</h3>

<p>Look for answer edited/posted by users <strong>drs</strong> and <strong>Joao S Veiga</strong> on <a href="https://unix.stackexchange.com/questions/18752/change-the-number-of-the-partition-from-sda1-to-sda2">unix.stackexchange.com</a></p>

<h3 id="force-unmounting-after-a-chroot-operation">Force unmounting after a chroot operation</h3>

<p>After exitting from a <code>chroot</code> environment, if you find yourself unable to unmount certain mountpoints (target busy, etc), try following the <a href="#my-other-cheat-sheet-links">Linux LVM guide below</a> first if your chroot environment is on LVM.</p>

<p>If all else failed, and you want to <em>force</em> unmount the mountpoint, issue:</p>

<pre><code class="language-shell">umount -lf /mountpoint;
</code></pre>

<p>This will <a href="https://unix.stackexchange.com/questions/61885"><em>force detach filesystem from fs heirarchy, and cleanup all references to the filesystem as soon as it&rsquo;s not busy</em></a></p>

<h3 id="console-backlight">Console backlight</h3>

<p>Most distributions place their console brightness configuration in <code>/sys/class/backlight/xxx/brightness</code></p>

<h2 id="certbot-with-nginx">certbot (with NGINX)</h2>

<p>Certbot can be used to automatically get new certificates and update your NGINX configuration to enable HTTPS in one command.</p>

<p>To obtain certificates (including the subdomains), and have Certbot modify your NGINX configuration, run:</p>

<pre><code class="language-shell">certbot --nginx -d &lt;DOMAIN_0&gt; [-d &lt;DOMAIN_1&gt;];
</code></pre>

<p>To see certificate information, run:</p>

<pre><code class="language-shell">certbot certificates;
</code></pre>

<p>To force-renew certificates <em>without reinstalling</em> the certificates (i.e. the NGINX configuration would <em>not</em> be modified), run:</p>

<pre><code class="language-shell">certbot certonly --force-renewal -d &lt;DOMAIN&gt;;
</code></pre>

<p>Or, if you have setup webroot:</p>

<pre><code class="language-shell">certbot certonly --webroot -w &lt;WEBROOT_DIR&gt; -d &lt;DOMAIN_NAME&gt;;
</code></pre>

<p>On Arch Linux with NGINX, include this snippet in your NGINX configuration to enable webroot:</p>

<pre><code>location ^~ /.well-known/acme-challenge/ {
    allow all;
    root /var/lib/letsencrypt/;
    default_type &quot;text/plain&quot;;
    try_files $uri =404;
}
</code></pre>

<p>The snippet above should be put in a <code>server</code> block
that listens on standard HTTP port 80.</p>

<p>For NGINX to serve HTTPS, add the following snippet to <code>server</code> block
listening on port 443.</p>

<pre><code>ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

include /etc/letsencrypt/options-ssl-nginx.conf;
ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
</code></pre>

<p>On FreeBSD, the package recommends putting the following line
in <code>/etc/periodic.conf</code> so that certbot will renew certificates periodically:</p>

<pre><code>weekly_certbot_enable=&quot;YES&quot;
</code></pre>

<p>Artnoi.com used both <code>cron</code> and <code>periodic.conf</code> schedulers when it was running
on FreeBSD and NGINX. Now it runs <a href="https://artnoi.com/blog/2020/openbsd-server/">OpenBSD</a>.</p>

<h2 id="screenshots-on-sway">Screenshots on Sway</h2>

<p>My prefered way to do this is to use 2 separate programs to take screenshots,
(1) <code>slurp</code> for selecting a region, (2) <code>grim</code> for actually capturing the image:</p>

<blockquote>
<p>The man page suggests that <code>-o &lt;OUTFILE&gt;</code> can be used to specify output file,
however, my experience in October 2022 was that <code>-o</code> flag does not work,
and you can just supply the outfile name as last argument.</p>
</blockquote>

<pre><code class="language-shell">grim -g &quot;$(slurp -d)&quot; /tmp/scrot.png
</code></pre>

<p>Or, if you want to redirect the output to stdout to <code>wl-copy</code>:</p>

<pre><code class="language-shell">grim -g &quot;$(slurp -d)&quot; - | wl-copy -t 'image/png';
</code></pre>

<p>This will capture the screenshot selected and piped to <code>wl-copy</code>.</p>

<h2 id="a-name-others-a-my-other-cheat-sheet-links"><a name="others"></a>My other cheat sheet links</h2>

<p><a href="/cheat/arch/">Arch Linux cheat sheet</a></p>

<p><a href="/blog/2019/arch-zfs/">Arch Linux ZFS root</a></p>

<p><a href="/cheat/zfs/">ZFS cheat sheet</a></p>

<p><a href="/cheat/device-mapper/">Device Mapper - LUKS and LVM</a></p>

<p><a href="/cheat/git/">Git cheat sheet</a></p>

<h2 id="my-cheat-sheet-links-for-noob-friends-noob"><a href="/noob/">My cheat sheet links for noob friends</a></h2>

<p><a href="/noob/block/">Storage (disks, etc.)</a></p>

<p><a href="/noob/boot/">Booting the computer</a></p>

<p><a href="/noob/desktop/">Minimal UNIX desktop</a></p>

<p><a href="/noob/vim/">Vim for noobs</a></p>
<hr>
<p><a href="#top">Back to top</a></p>
<hr>
<footer>
	<p>Copyright (c) 2019 - 2023 Prem Phansuriyanon</p>
	<p>Verbatim copying and redistribution of this entire page are permitted provided this notice is preserved</p>
</footer>
</body>

</html>